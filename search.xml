<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实用工具软件分享</title>
    <url>/2021/11/10/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>本人平时喜欢收集一些好用的软件，正好最近在研究个人博客，就想通过这篇个人博客向大家分享下自己的一些工具，同时也方便为自己做个记录，软件均通过蓝奏云（100M以下）或分秒帧分享，访问密码统一：<code>lzlz</code>,收藏不易，各位好友，各自获取</p>
<span id="more"></span>

<h1 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h1><h2 id="一、通用工具"><a href="#一、通用工具" class="headerlink" title="一、通用工具"></a>一、通用工具</h2><h3 id="1-截屏、录屏工具"><a href="#1-截屏、录屏工具" class="headerlink" title="1.截屏、录屏工具"></a>1.截屏、录屏工具</h3><ol>
<li>Snipaste</li>
</ol>
<p>snipaste是我最常用的截屏工具，相比其他截屏我更喜欢它的悬浮截屏，</p>
<p>按下F1快捷键截屏后按下F3就可以将截下的图在屏幕上置顶随意拖动缩放，对于像我这样靠着C+V大法的底层码农来copy代码是再方便不过了。</p>
<p>获取方式：</p>
<ul>
<li>官网下载：<a href="https://www.snipaste.com/download.html">点击下载</a></li>
<li>蓝奏云获取：<a href="https://www.lanzouw.com/ir6PTwpb13c">点击下载</a></li>
</ul>
<ol start="2">
<li>fscapture_33lc</li>
</ol>
<p>这款软件用于截图，也很强大，不仅实现了各种窗口截屏和任意区域截屏，还继承了录屏的功能。最主要的是文件体积小、免安装，随点随用，录制的屏幕视频清晰度很高，建议大家都有一套，指不定什么时候要录个屏不用到处去装软件，视频不清晰不说，要注册就很麻烦，最主要还有logo,这还能忍？</p>
<ul>
<li>蓝奏云获取：<a href="https://www.lanzouw.com/iAn1Dwpb70f">点击下载</a></li>
</ul>
<ol start="3">
<li>Bandicam</li>
</ol>
<p>术业有专攻，<code>fscapture</code>虽然很强又免安装，我们有偶尔的录屏需求是首选，如果我们需要经常录制视频或者对视频的画质、格式等有更高要求，装一款Bandicam不失为上选，界面功能齐全，风格nice~</p>
<ul>
<li>蓝奏云获取：<a href="https://www.lanzouw.com/iVUw4wpbjmj">点击下载</a></li>
</ul>
<h3 id="2-下载工具"><a href="#2-下载工具" class="headerlink" title="2.下载工具"></a>2.下载工具</h3><ol>
<li>IDM</li>
</ol>
<p>IDM可以说是一款及其良心的下载软件了，可以作为配置为各浏览器插件在下载时会默认实用其进行下载，主要优点让我非常喜欢的有：</p>
<ul>
<li><p>多线程下载，下载速度非常快</p>
</li>
<li><p>可以抓取网页上的视频、音频</p>
</li>
<li><p>可以通过输入链接方式下载</p>
</li>
<li><p>不限速，无需登录，不像迅雷要氪金</p>
</li>
<li><p>蓝奏云获取：<a href="https://www.lanzouw.com/ivNYQwpb7id">点击下载</a></p>
</li>
</ul>
<h3 id="3-本地看视频工具"><a href="#3-本地看视频工具" class="headerlink" title="3.本地看视频工具"></a>3.本地看视频工具</h3><ol>
<li>Pot-Player</li>
</ol>
<p>看视频工具很多，pot-player是我一直在用的一款，主要优势我认为有以下几点：</p>
<ul>
<li>体积小，运行快，不卡顿，安装卸载方便</li>
<li>支持多种格式视频文件，基本你要的他都有</li>
<li>功能齐全，麻雀虽小，五脏俱全</li>
<li>蓝奏云获取：<a href="https://www.lanzouw.com/iXE5ewpb7fa">点击下载</a></li>
</ul>
<h3 id="4-解压缩软件"><a href="#4-解压缩软件" class="headerlink" title="4.解压缩软件"></a>4.解压缩软件</h3><ol>
<li>BanDizip</li>
<li>Winrar</li>
</ol>
<p>解压软件我一般使用这两款，winrar感觉要更稳定强一些，毕竟时大公司出品嘛~，bandizip风格蛮好的，很喜欢。但这都不是喜欢他们的最主要理由，最主要的是他们都不会携带私货，捆绑各种流氓软件和病毒。由于我一直没有去升级版本，所以目前是不是接了广告暂时还不清楚。</p>
<ul>
<li>bandizip 蓝奏云获取：<a href="https://www.lanzouw.com/ieP5pwpbihi">点击下载</a></li>
<li>winrar 蓝奏云获取：<a href="https://www.lanzouw.com/iIjcQwpbikb">点击下载</a></li>
</ul>
<h3 id="5-卸载软件"><a href="#5-卸载软件" class="headerlink" title="5.卸载软件"></a>5.卸载软件</h3><ol>
<li>Uninstall Tool</li>
</ol>
<p>我们卸载软件总不能相信软件自带卸载工具会卸载干净吧，这款工具可以把要卸载软件相关联的注册表都给干掉，所以体验还是非常爽的，最最主要还是不用安装，即点即用，非常省心呐</p>
<ul>
<li>蓝奏云获取：<a href="https://www.lanzouw.com/iJsxxwpb7ni">点击下载</a></li>
</ul>
<h3 id="6-远程工具"><a href="#6-远程工具" class="headerlink" title="6.远程工具"></a>6.远程工具</h3><ol>
<li>向日葵</li>
</ol>
<p>市面上可能有各种好用的远程控制工具，但我一直用的都是向日葵，能够满足我的正常需求，同理最最主要的就是它有绿色版，免安装，操作也很简单~</p>
<ul>
<li>官网：<a href="https://sunlogin.oray.com/download/">点击下载</a></li>
<li>蓝奏云：<a href="https://www.lanzouw.com/iXDawwpbp2f">点击下载</a></li>
</ul>
<h3 id="7-装机工具"><a href="#7-装机工具" class="headerlink" title="7.装机工具"></a>7.装机工具</h3><ol>
<li>UltraISO</li>
</ol>
<p>软碟通是光盘映像文件制作/编辑/转换工具，也就是说我们可以通过这款工具将操作系统ISO镜像刻录到U盘中，然后通过U盘装机。这种方法最为安全，因为不牵涉第三方软件，所以在刻录过程中不会有第三方软件携带，如果操作系统镜像就是干净的，那么装出的操作系统必是干净的</p>
<ol start="2">
<li><a href="https://u.diannaodian.com/">电脑店</a></li>
<li><a href="http://laobaicai.qingxruanj.top/">大白菜</a></li>
</ol>
<p>电脑店和大白菜都是U盘启动盘制作工具，这么描述吧，它们是专业干这个的，而UltralISO制作启动盘并不是主要工作，UltraISO是对ISO镜像文件操作的，而装机无非就是把镜像文件拷贝过去，所以它具备这种功能。如果图省心，使用电脑店和大白菜也是推荐的，而且他们的功能不止于此，忘记密码重置、磁盘文件找回都可以实现。当我们C盘有文件要保留，系统又登不上去了，可以使用这两款，这时候就不能用UltralSO了。</p>
<ul>
<li>蓝奏云：<a href="https://www.lanzouw.com/ixZIjwprugf">点击下载</a></li>
</ul>
<h3 id="8-虚拟机软件"><a href="#8-虚拟机软件" class="headerlink" title="8.虚拟机软件"></a>8.虚拟机软件</h3><ol>
<li>vmware workstation</li>
<li>VirtualBox</li>
</ol>
<p>对于要学开发的，同学，Linux操作系统是必须要掌握的一门技能，这样的话我们必须要有一套LInux环境，就目前来看，学习的话我还是推荐CentOS系统，对于操作的话其实没大的区别啦，那么我们获得这样一个环境有哪几种方式呢：</p>
<ul>
<li>购买云服务器</li>
<li>装双系统</li>
<li>装虚拟机</li>
</ul>
<p>购买云服务器，又要花钱，又不能体验装系统的过程，在学习阶段自然不是很好的选择</p>
<p>装双系统呢，听起来挺Cool,但其实没什么，来回切系统，还是有些麻烦的，比到最后肯定还是装虚拟机占优势呀</p>
<p>虚拟机软件挺多的，我之前用的是vmware workstation，老牌软件，放心，我们只是依靠这款软件模拟一个真实的物理机器，操作并不在上面进行，这些软件如果自己有合适的也可以使用。</p>
<p>关于使用虚拟机的好处再插一句，我们克隆出多个镜像，从而实现模拟集群的效果</p>
<p>关于使用虚拟机安装CentOs操作系统，我之前也写了一篇文章，有兴趣的伙伴可以看看：<a href="https://blog.csdn.net/wowoniu1997/article/details/120809705?spm=1001.2014.3001.5501">Linux环境搭建保姆级操作</a></p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/Mqyhvl">点击下载</a></li>
</ul>
<h3 id="9-文档工具"><a href="#9-文档工具" class="headerlink" title="9.文档工具"></a>9.文档工具</h3><ol>
<li>office</li>
<li>wps</li>
</ol>
<p>关于编写文档，以前在校的时候经常写文档、ppt所以特别推荐office套装，懂得都懂，非常好用</p>
<p>后面开发的话，写文档和ppt并不是很多，然后电脑又自带了office，哈哈哈，虽然还是用它，但是如果电脑没有office,或者用的不多，只是用来看文章、ppt、excel做一些简单操作用Wps就能胜任了，而且现在wps功能很强啊。</p>
<ul>
<li>office 文件太大，有需要的点关于，联系获取</li>
<li>wps  分秒帧：<a href="https://mdl.ink/DEWZVh">点击下载</a></li>
</ul>
<h3 id="10-画图工具"><a href="#10-画图工具" class="headerlink" title="10.画图工具"></a>10.画图工具</h3><ol>
<li><a href="https://www.processon.com/">ProcessOn</a></li>
<li>xmind</li>
<li>visio</li>
</ol>
<p>好记性不如烂笔头,画图比文章有事来的更清晰明了，推荐了3个画图工具</p>
<p>processOn是一个在线画图网站，只需要微信或者QQ登录就行，虽然有文件数量限制，但是不妨碍你把一个稿纸拉的大大的，就可以一直画一直拉大了，嘿嘿。</p>
<p>processOn上面基本能够满足我们所需的各种图，流程图，UML等均可以实现，而且免费导出各种形式，并且我们画完会自动保存，再也不用担心画完之后时间长了找不到了</p>
<p>xmind则是专业画流程图的客户端软件，拥有各种主题，操作简单，样式好看，别说了，我要去画图啦~</p>
<p>visio专业中的专业，听说大神都是用这画的，如果你也是大神，去试试吧~</p>
<ul>
<li>xmind: 分秒帧：<a href="https://mdl.ink/LW5mix">点击下载</a></li>
<li>visio：文件太大，有需要的联系获取</li>
</ul>
<h2 id="二、开发工具"><a href="#二、开发工具" class="headerlink" title="二、开发工具"></a>二、开发工具</h2><h3 id="1-轻文本编译器"><a href="#1-轻文本编译器" class="headerlink" title="1.轻文本编译器"></a>1.轻文本编译器</h3><ol>
<li><p>sublimeText</p>
</li>
<li><p>notepad++</p>
</li>
<li><p>Typora</p>
</li>
</ol>
<p>轻文本编译器我们主要用来替代记事本使用，所以我们主要关注的点无非以下几条：</p>
<ol>
<li>体积小，安装方便，甚至要求不用安装</li>
<li>响应快，不卡顿，这点是最重要的，作为替代记事本的工具，不能打开个txt文件花个几分钟吧</li>
<li>必要的功能齐全但又不要过多的无用功能，满足常用的一些使用即可，太多的功能反而操作不舒服</li>
</ol>
<p>sublimeTxt和notepad++都是我一直使用的，我喜欢sublimtext的界面风格以及右侧代码缩略图体验感都是相当nice</p>
<p>必不可少我的Typora，我愿称之为yyds,因为采用的是markDown语法，我一般用来写文章、博客做笔记都很舒服，但是替代记事本我觉得还是没必要，因为角度不一样，如果你的目的是写笔记之类的那一定首选它了~哈哈哈哈</p>
<ul>
<li>sublimeText 官网: <a href="http://www.sublimetext.com/">点击下载</a></li>
<li>notepad++ 官网：<a href="https://notepad-plus.en.softonic.com/">点击下载</a></li>
<li>typora 官网：<a href="https://www.typora.io/">点击下载</a></li>
</ul>
<h3 id="2-前端编译工具"><a href="#2-前端编译工具" class="headerlink" title="2.前端编译工具"></a>2.前端编译工具</h3><ol>
<li>vscode</li>
</ol>
<p>这款工具应该是目前非常火热的开发工具了，相对webstorm的重量来说，小轻便即是优势。</p>
<p>体积虽小，功能不小，它的插件系统让它非常之灵活，根据需要你可以为其安装相应的插件，能够完成各种工作，设置后开发Java也非常方便。</p>
<ul>
<li>蓝奏云：<a href="https://www.lanzouw.com/iYxmOwpccab">点击下载</a></li>
<li>官网：<a href="https://code.visualstudio.com/docs/?dv=win">点击下载</a></li>
</ul>
<ol start="2">
<li>Hbuilder</li>
</ol>
<p>这款软件是国内开发的，所以使用上会发现更得心应手，开发前端还可以无需打开浏览器，边写边预览，相当舒服。如果是使用H5做app简直就是量身定做，哈哈哈，需要的小伙伴可以看看，因为我主要工作不是开发前端，所以这款目前用的不多，主要是上学时间使用。</p>
<ul>
<li>官网：<a href="https://www.dcloud.io/hbuilderx.html">点击下载</a></li>
<li>分秒帧：<a href="https://mdl.ink/pj4k1m">点击下载</a></li>
</ul>
<h3 id="3-Java开发工具"><a href="#3-Java开发工具" class="headerlink" title="3.Java开发工具"></a>3.Java开发工具</h3><ol>
<li>Idea</li>
</ol>
<p>说到java开发工具，不用想排在第一的必是idea，功能已经很是齐全，做这方面开发的同学都知道，yyds~</p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/S8mmac">点击下载</a></li>
<li>官网：<a href="https://www.jetbrains.com/idea/">点击下载</a></li>
</ul>
<ol start="2">
<li>Eclipse</li>
</ol>
<p>因为是免费并且功能也很强大，老牌java开发IDE,因为其免费，所以现在很多软件公司对版权比较重视的都会明面上首选Exlipse作为主开发工具</p>
<ul>
<li>官网：<a href="https://www.eclipse.org/downloads/">点击下载</a></li>
</ul>
<h3 id="4-java依赖工具"><a href="#4-java依赖工具" class="headerlink" title="4.java依赖工具"></a>4.java依赖工具</h3><ol>
<li>JDK</li>
</ol>
<p>java编译运行工具，目前常用的是JDk8和JDK11</p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/CrVq8L">点击下载</a></li>
</ul>
<ol start="2">
<li>maven<ul>
<li>官网下载：<a href="http://maven.apache.org/download.cgi">点击下载</a></li>
<li><a href="http://archive.apache.org/dist/maven/">点击下载</a></li>
</ul>
</li>
<li>tomcat<ul>
<li>官网下载：<a href="https://tomcat.apache.org/download-80.cgi">点击下载</a></li>
<li><a href="http://archive.apache.org/dist/tomcat/">点击下载</a></li>
</ul>
</li>
</ol>
<h2 id="三、数据库工具"><a href="#三、数据库工具" class="headerlink" title="三、数据库工具"></a>三、数据库工具</h2><h3 id="1-DataGrip"><a href="#1-DataGrip" class="headerlink" title="1.DataGrip"></a>1.DataGrip</h3><p>最近越来越火的数据库工具，是JetBrains公司开发的，功能已经相当完整，最常用的Mysql、Oracle都不在话下，如果你使用的是Idea开发的化，大可不必单独装个DataGrip,在Idea里已经内嵌了这样一个工具，想象下我们开发代码、查库都用一个工具，写Sql和写代码一样不是很舒服嘛</p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/QMr91l">点击下载</a></li>
</ul>
<h3 id="2-Navicat"><a href="#2-Navicat" class="headerlink" title="2.Navicat"></a>2.Navicat</h3><p>相信大家用的最多的都是这款，因为它确实很方便，提供了非常细心的可视化操作功能，不懂sql编写也能够操作数据库</p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/QMr91l">点击下载</a></li>
</ul>
<h3 id="3-PLSql"><a href="#3-PLSql" class="headerlink" title="3.PLSql"></a>3.PLSql</h3><p>这是一款专门为Oracle数据库量身打造的数据库，在处理Oracle上得心应手，如果对Oracle数据库操作频繁且要求功能比较多时，PlSql才是首选</p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/NhYXFA">点击下载</a></li>
</ul>
<h3 id="4-Dbever"><a href="#4-Dbever" class="headerlink" title="4.Dbever"></a>4.Dbever</h3><p>这是一款后起之秀，不过难用是真的难用。但是开源、可定制。所以规模稍大的公司，对版权有要求，就会在这款工具上下文章了，个人使用还是不推荐啦~</p>
<ul>
<li>官网：<a href="https://dbeaver.io/">点击下载</a></li>
</ul>
<h3 id="5-PowerDesign"><a href="#5-PowerDesign" class="headerlink" title="5.PowerDesign"></a>5.PowerDesign</h3><p>以上都是数据库操作工具，powerDesigner是一款数据库设计软件，在软件开发团队开发之前设计表结构时必用工具。关于这个工具的安装破解以及简单实用教程，请大家参阅我的CSDN博客文章：<a href="https://blog.csdn.net/wowoniu1997/article/details/120503629?spm=1001.2014.3001.5501">powerDesigner的安装及简单使用</a></p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/BPS9eF">点击下载</a></li>
</ul>
<h2 id="四、开发辅助工具"><a href="#四、开发辅助工具" class="headerlink" title="四、开发辅助工具"></a>四、开发辅助工具</h2><h3 id="1-Postman"><a href="#1-Postman" class="headerlink" title="1.Postman"></a>1.Postman</h3><p>开发同学都知道这款软件是干什么的，我们常用postman来发起请求获取相应数据，对于现在前后端分离开发，后端人员开发接口，再调试接口过程中必用的工具，通过Get、Post、Delete、Put发送不同请求，找到后台具体处理的Handler，前端人员也通过这款工具查看返回的数据格式、字段便于开发</p>
<ul>
<li>官网：<a href="https://www.postman.com/downloads/?utm_source=postman-home">点击下载</a></li>
<li>分秒帧：<a href="https://mdl.ink/oqMqRs">点击下载</a></li>
</ul>
<h3 id="2-Jd-gui"><a href="#2-Jd-gui" class="headerlink" title="2.Jd-gui"></a>2.Jd-gui</h3><p>java反编译工具，我们用来查看源码，或者从生产环境拉下来的jar包，class文件等都是已经经过编译的，通过java发编译工具来查看编译前内容，可以用来定位线上问题，或者学习框架等</p>
<ul>
<li>蓝奏云：<a href="https://www.lanzouw.com/i0X07wpdd2f">点击下载</a></li>
</ul>
<h3 id="3-Git、SVN"><a href="#3-Git、SVN" class="headerlink" title="3.Git、SVN"></a>3.Git、SVN</h3><p>团队协作开发工具，目前市场上主流的还是这两种，GIt将是后面一段时间的主流工具，不过一些公司项目可能时间比较久使用的是SVN,但从团队开发协作上来讲，如果一个项目开发团队人数不是很多情况下，其实差不多。人数多的话还是Git占优势，关于Git的一些简介和基本使用可以看我的这篇文章，本人也是开发刚入门，不足之处，大家多读指点：<a href="https://liuzhengkaifa.github.io/2021/11/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">git常用操作</a></p>
<ul>
<li>Git 蓝奏云：<a href="https://www.lanzouw.com/iXaJywpc15a">点击下载</a></li>
<li>svn 蓝奏云：<a href="https://www.lanzouw.com/id0oLwpf5da">点击下载</a></li>
</ul>
<h3 id="4-Cmder"><a href="#4-Cmder" class="headerlink" title="4.Cmder"></a>4.Cmder</h3><p>经常使用Mac或者对linux系统比较熟悉的伙伴肯定觉得敲命令行来处理各种工作效率更高，更cool,甚至可以摆脱鼠标的束缚。cmder可以在windows上运行，我们只需要下载下来，也是免安装的，即点即用，最最重要的是它集成了linux的常用指令，我们可以在windows电脑上甚至像操作linux一样写命令。</p>
<p>而且这款软件是自带了GIt的，我们使用这款软件的像前面的Git工具其实是不需要再安装的，是不是很良心呐~</p>
<ul>
<li>官网地址：<a href="https://cmder.net/">点击下载</a></li>
<li>分秒帧：<a href="https://mdl.ink/P9KsI0">点击下载</a></li>
</ul>
<h3 id="5-GitHubDesktop"><a href="#5-GitHubDesktop" class="headerlink" title="5.GitHubDesktop"></a>5.GitHubDesktop</h3><p>不论是用git或者svn的同学，肯定都是喜欢使用方便操作的图形化工具，相信大家经常用的都是小乌龟<code>Tortoise</code>，之前用svn时候我也用了一段时间，后台用了GIt,我的开发领导推荐了我这款可视化工具，用过之后感觉是香，而且他是Git官方退出的，界面风格简单，操作简单，有兴趣的小伙伴可以尝试使用</p>
<p>不过想Idea等开发工具就已经集成了Git，我们再提交代码时有时候通过编译器就直接操作了，这个就看个人习惯了</p>
<ul>
<li>官网地址：<a href="https://desktop.github.com/">点击下载</a></li>
<li>蓝奏云：<a href="https://mdl.ink/GlVCdH">点击下载</a></li>
</ul>
<h3 id="6-BeyondCompar"><a href="#6-BeyondCompar" class="headerlink" title="6.BeyondCompar"></a>6.BeyondCompar</h3><p>文件比对工具，这款软件可以说是专为svn而生，使用svn的同学不知道有没有在用，我们都知道svn合并分支代码时候是件麻烦事，有了这款软件加持算是有了神器。通过这款软件可以比对两边文件夹，设定过滤规则，能够筛选出有差异的文件，打开文件后能够显示两边文件的去边，你可以点按钮选择采用左边的或者右边的，当然也可以自己手动调整。</p>
<p>不仅仅是使用再SVN上，我们经常修改了很多文件后不知道自己具体改了哪些，如果没有版本控制的情况下，例如这个工具和源文件一比对，修改的内容一清二楚，非常的nice~</p>
<ul>
<li>官网地址：<a href="https://www.beyondcompare.cc/xiazai.html">点击下载</a></li>
<li>分秒帧：<a href="https://www.lanzouw.com/iLP7Rwpc2bc">点击下载</a></li>
</ul>
<h3 id="7-MobaXterm"><a href="#7-MobaXterm" class="headerlink" title="7.MobaXterm"></a>7.MobaXterm</h3><p>这是新发现的一款神器，相比xshell感觉一些功能更吸引我</p>
<blockquote>
<p>你将被允许运行你需要的 Unix 命令：ls、cd、grep、awk、tail、cut、sed、wget、rsync、telnet、ssh、rlogin、rsh …所有基本的 Unix 工具存在。如果您需要基本 MobaXterm 文件中没有的程序，您可以下载免费插件</p>
</blockquote>
<p>这意味着我们在window电脑上也可以实用linux服务器的命令，这样的话之前的cmder功能在这也能实现</p>
<blockquote>
<p>当您使用 SSH 登录到远程服务器时，左侧边栏中会弹出一个图形 SFTP 浏览器。它允许您使用安全的 SFTP 连接将文件直接从/拖放到远程服务器。</p>
</blockquote>
<p>sftp就在终端的左边，可以随意拖动实现服务器和本地文件交互</p>
<blockquote>
<p>当您使用 SSH 连接到远程服务器时，只需双击它们，您就可以使用嵌入式文本编辑器“MobaTextEditor”直接编辑远程文件！</p>
</blockquote>
<p>相比vi和vim，实用文本编辑器更方便，当然还有一些其他好用的功能，赶紧体验起来，可以官网下载家庭免费版，免安装哦~</p>
<ul>
<li><p><a href="https://mobaxterm.mobatek.net/">官网地址</a></p>
</li>
<li><p>蓝奏云：<a href="https://www.lanzouw.com/iDGvqwpbxub">点击下载</a></p>
</li>
</ul>
<h3 id="8-Xshell"><a href="#8-Xshell" class="headerlink" title="8.Xshell"></a>8.Xshell</h3><p>这款大家肯定都很熟悉，连接服务器，替代服务器终端，点击上方的xftp也可以实现本地和服务器之间的文件传递，用起来还是相当方便</p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/Myb6mN">点击下载</a></li>
</ul>
<h3 id="9-Chrome"><a href="#9-Chrome" class="headerlink" title="9.Chrome"></a>9.Chrome</h3><p>谷歌浏览器，开发必备浏览器，因其强大的调试控制台对于开发调试来说提供了很大帮助</p>
<ul>
<li>分秒帧：<a href="https://mdl.ink/KSZSQB">点击下载</a></li>
<li>蓝奏云：<a href="https://www.lanzouw.com/iDEaBwpcxxa">点击下载</a></li>
</ul>
<h2 id="五、实用网站"><a href="#五、实用网站" class="headerlink" title="五、实用网站"></a>五、实用网站</h2><h3 id="1-分秒帧"><a href="#1-分秒帧" class="headerlink" title="1.分秒帧"></a>1.<a href="https://app.mediatrack.cn/">分秒帧</a></h3><p>用这个网站登录之后就相当于有了一块无限制大小的网盘，不限速哦~，如果担心资源安全问题，上传一些软件、学习课程类的相当方便</p>
<h3 id="2-蓝奏云"><a href="#2-蓝奏云" class="headerlink" title="2.蓝奏云"></a>2.<a href="https://up.woozooo.com/u">蓝奏云</a></h3><p>下载速度块，单个文件大小有限制，只能上传100M以下软件</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除了以上工具，还有不少使用的工具，像pdf转换、合并，视频格式转化，各种破解工具因为比较杂比较乱，等梳理清晰了再修改在上面，因为GIthub上不能上传100M以上的文件,所以有兴趣想获取软件，有一些在官网，或者交流的同学可以加个wx，一起探讨交流</p>
<img src="/2021/11/10/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/image-20211110221656622.png" alt="image-20211110221656622" style="zoom:50%;">



]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性Hash算法及在Nginx负载均衡策略上的应用</title>
    <url>/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>博文介绍了普通hash算法、一致性hash算法、一致性hash算法在Nginx负载均衡策略中的应用，文章主要来源拉钩高薪训练营相关内容+自己的理解，条理清晰，能够帮助理解hash算法到底在查询和存储过程或者是负载均衡中到底起了什么样的作用，为什么会有那么高的效率?有兴趣的小伙伴可以了解下</p>
<span id="more"></span>

<h1 id="一、普通Hash算法"><a href="#一、普通Hash算法" class="headerlink" title="一、普通Hash算法"></a>一、普通Hash算法</h1><h2 id="1、哈希算法的用处"><a href="#1、哈希算法的用处" class="headerlink" title="1、哈希算法的用处"></a>1、哈希算法的用处</h2><p>哈希算法主要用于数据查询、存储、安全加密等领域，例如Java中的HashTable,Git中的索引，MD5、SHA等</p>
<h2 id="2、为什么要使用Hash算法"><a href="#2、为什么要使用Hash算法" class="headerlink" title="2、为什么要使用Hash算法"></a>2、为什么要使用Hash算法</h2><p>查询效率高，hash算法设计好的话，使用hash算法查询时间复杂度能够达到n(1)，即实现一次查询。</p>
<h2 id="3、Hash算法到底是什么"><a href="#3、Hash算法到底是什么" class="headerlink" title="3、Hash算法到底是什么"></a>3、Hash算法到底是什么</h2><p>hash算法不是一种算法，而是<strong>一类算法</strong>。</p>
<p>主要都是实现：<strong>给一个任意大小的数据生成一个固定长度的数据，作为它的一个映射，一一对应</strong>。</p>
<p>下面通过一个最普通简单的hash算法（除留余数法）来理解下hash算法：</p>
<p>就是给定一个固定长度的数组，和一个数</p>
<p>hash算法：就是将这个数对数组长度进行求模（即求余数），得到的结果就是哈希值</p>
<p>那么这个数和这个哈希值就建立了一一对应的关系，将这个数即可存放在数组下标值为它的哈希值的数组中，因此，判断这个数组有没有这个值时，只需要计算出这个值的hash值，直接根据数组下标查询是否为空即可得出结论。</p>
<p><strong>问题</strong>：上面是最简单的hash算法，肯定会有问题出现，如多个数据通过求余数得到的结果一直，怎么都存在一个下标处，这就产生了hash冲突，解决的方法有开发寻址法，和拉链法，后面会讲到。这只是个示例，实际的hash算法要复杂很多，而且hash算法的研究一直在持续~</p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120092911825.png" alt="image-20211120092911825"></p>
<ol>
<li>开发寻址法</li>
</ol>
<p>如果数据是1， 6， 7， 8，把这4个数据存储到上⾯的数组中 </p>
<p>开发寻址法的解决策略：</p>
<p>1 放进去了， 6再来的时候，向前或者向后找空闲位置存放</p>
<p>缺陷:</p>
<p>如果数组⻓度定义好了⽐如10，⻓度不能扩展，来了11个数据，不管Hash冲突不冲突，肯定存不下这么多数据 </p>
<ol start="2">
<li>拉链法</li>
</ol>
<p>数据⻓度定义好了，怎么存储更多内容呢，算好Hash值，在数组元素存储位置放了⼀个链表  </p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120093204024.png" alt="image-20211120093204024"></p>
<p>如果Hash算法设计的⽐较好的话，那么查询效率会更接近于O(1)，如果Hash算法设计的⽐较low，那么<br>查询效率就会很低了  </p>
<img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120093237536.png" alt="image-20211120093237536" style="zoom:50%;">

<p>因此，Hahs表的查询效率高不高取决于Hash算法，Hash算法能够让数据平均分布，既能够节省空间，又能够提高查询效率。Hash算法的研究是一门很高深的学问，甚至很多数学见也在研究中。</p>
<p>HashCode就是通过一种hash算法得出的。</p>
<h1 id="二、一致性哈希算法"><a href="#二、一致性哈希算法" class="headerlink" title="二、一致性哈希算法"></a>二、一致性哈希算法</h1><h2 id="1、普通Hash算法的弊端"><a href="#1、普通Hash算法的弊端" class="headerlink" title="1、普通Hash算法的弊端"></a>1、普通Hash算法的弊端</h2><p>例如Nginx自带的负载均衡策略ip_hash来说，根据IP地址的局域网段通过hash算法，将访问同一网段的客户端请求转发到同一台实现负载均衡的服务器上，虽然这样会避免session一致性问题，但是当其中一台服务器宕机了，根据求模得到的hash值便要重新计算，重新得到的hash值会将之前部分客户端请求转发到其它服务器上，从而会丢失sesssion登录信息等。</p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120094829847.png" alt="image-20211120094829847"></p>
<p>因为搭建了集群的服务器生产情况下，后台服务器很多，访问的客户端也有很多，所以一台宕机或者新增一台服务器影响会是很大的。缩容和扩容都会存在这样的问题，大量的用户请求会被转发到其它服务器上，保存在之前服务器中的会话信息便会丢失。</p>
<h2 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h2><h3 id="（一）Hash算法在分布式架构中的应用场景："><a href="#（一）Hash算法在分布式架构中的应用场景：" class="headerlink" title="（一）Hash算法在分布式架构中的应用场景："></a>（一）Hash算法在分布式架构中的应用场景：</h3><p>​        hash算法在分布式集群产品中都有应用，比如分布式集群架构Redis,Hadoop,ElasticSearch，Mysql分库分表， Nginx负载均衡等 </p>
<h3 id="（二）应用场景归纳"><a href="#（二）应用场景归纳" class="headerlink" title="（二）应用场景归纳"></a>（二）应用场景归纳</h3><ol>
<li>请求的负载均衡（比如Nginx的ip_hash）</li>
</ol>
<p>Nginx的ip_hash在上面已经描述过了，虽然有弊端，但是也是实现了在客户端IP地址不变的情况下，将其发出的请求始终路由到同一台服务器上，实现会话粘滞，避免处理session共享问题</p>
<p>如果没有ip_hash策略，怎么实现会话粘滞</p>
<p>​    可以维护⼀张映射表，存储客户端IP或者sessionid与具体⽬标服务器的映射关系  </p>
<p>​    &lt;ip,tomcat1&gt;<br>缺点</p>
<ol>
<li>那么，在客户端很多的情况下，映射表⾮常⼤，浪费内存空间</li>
<li>客户端上下线，⽬标服务器上下线，都会导致重新维护映射表，映射表维护成本很大</li>
</ol>
<p>如果使⽤哈希算法，事情就简单很多，我们可以对ip地址或者sessionid进⾏计算哈希值，哈希值与服务<br>器数量进⾏取模运算，得到的值就是当前请求应该被路由到的服务器编号，如此，同⼀个客户端ip发送<br>过来的请求就可以路由到同⼀个⽬标服务器，实现会话粘滞。 </p>
<ol start="2">
<li>分布式存储</li>
</ol>
<p>以分布式内存数据库Redis为例,集群中有redis1， redis2， redis3 三台Redis服务器那么,在进⾏数据存储时,&lt;key1,value1&gt;数据存储到哪个服务器当中呢？针对key进⾏hash处理hash(key1)%3=index, 使⽤余数index锁定存储的具体服务器节点  </p>
<h3 id="（三）什么是一致性Hash算法"><a href="#（三）什么是一致性Hash算法" class="headerlink" title="（三）什么是一致性Hash算法"></a>（三）什么是一致性Hash算法</h3><p>一致性hash算法的思路：</p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120101023499.png" alt="image-20211120101023499"></p>
<p>有这样一条直线，起始从0开始，结束为2的32次方-1，这也是Integer整数的取值范围，我们把它相当于地址，我们将这样一条线弯曲闭成一个环形，这样一个圆环我们就称之为<strong>hash环</strong>，我们把服务器的ip地址或者主机名求hash值然后对应到hash环上，那么针对客户端ip地址进行hash求值，对应到环上的某个位置，然后如何确定一个客户端的请求该由那一台服务器处理呢，即可按照hash环的顺时针方向，最近的服务器即处理来自hash环上的客户端请求</p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120101639305.png" alt="image-20211120101639305"></p>
<p>这样的话，当hash环上的服务区3宕机下线，原来请求路由到3上的客户端会被转发到服务器4，而其它客户端请求则不会收到影响，使得请求的迁移达到了最小，对客户端的影响也降低了，这样的算法对于分布式来说是非常合适的</p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120102036135.png" alt="image-20211120102036135"></p>
<p>增加服务器5之后，原来路由到3的部分客户端路由到新增服务器5上，对于其他客户端没有影响只是这⼀⼩部分受影响（请求的迁移达到了最⼩，这样的算法对分布式集群来说⾮常合适的，避免了⼤量请求迁移 ）  </p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120102153533.png" alt="image-20211120102153533"></p>
<ol>
<li>优势</li>
</ol>
<p>如前所述，每⼀台服务器负责⼀段，⼀致性哈希算法对于节点的增减都只需重定位环空间中的⼀⼩部分数据，具有较好的容错性和可扩展性。  </p>
<ol start="2">
<li>弊端</li>
</ol>
<p>但是，⼀致性哈希算法在服务节点太少时，容易因为节点分部不均匀⽽造成数据倾斜问题。例如系统中只有两台服务器，其环分布如下，节点2只能负责⾮常⼩的⼀段，⼤量的客户端请求落在了节点1上，这就是数据（请求）倾斜问题  </p>
<h4 id="1、增加虚拟节点"><a href="#1、增加虚拟节点" class="headerlink" title="1、增加虚拟节点"></a>1、增加虚拟节点</h4><p>为了解决这种数据倾斜问题，⼀致性哈希算法引⼊了虚拟节点机制，即对每⼀个服务节点计算多个哈希，每个计算结果位置都放置⼀个此服务节点，称为虚拟节点  </p>
<p>具体做法可以在服务器ip或主机名的后⾯增加编号来实现。⽐如，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “节点1的ip#1”、 “节点1的ip#2”、 “节点1的ip#3”、 “节点2的ip#1”、 “节点2的ip#2”、 “节点2的ip#3”的哈希值，于是形成六个虚拟节点，当客户端被路由到虚拟节点的时候其实是被路由到该虚拟节点所对应的真实节点  </p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120102503565.png" alt="image-20211120102503565"></p>
<h2 id="3、手写实现简单hash算法和一致性hash算法"><a href="#3、手写实现简单hash算法和一致性hash算法" class="headerlink" title="3、手写实现简单hash算法和一致性hash算法"></a>3、手写实现简单hash算法和一致性hash算法</h2><h3 id="（一）普通hash算法实现"><a href="#（一）普通hash算法实现" class="headerlink" title="（一）普通hash算法实现"></a>（一）普通hash算法实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GeneralHash &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.定义客户端IP</span><br><span class="line">        String[] clients = new String[]&#123;&quot;192.168.0.1&quot;,&quot;192.168.0.2&quot;,&quot;192.168.0.3&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        //2.定义服务器数量</span><br><span class="line">        int serverCount = 5;</span><br><span class="line"></span><br><span class="line">        //使用hash(ip)%serverCount = index 根据index索引锁定应该路由到的tomcat服务器</span><br><span class="line">        for (String client:clients) &#123;</span><br><span class="line">            int client_hash = Math.abs(client.hashCode());</span><br><span class="line">            int index = client_hash%serverCount;</span><br><span class="line">            System.out.println(client+&quot;请求被转发到了服务器：&quot;+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（二）一致性hash算法不带虚拟节点"><a href="#（二）一致性hash算法不带虚拟节点" class="headerlink" title="（二）一致性hash算法不带虚拟节点"></a>（二）一致性hash算法不带虚拟节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsistentHashNoVirtual &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //step1 初始化：把服务器节点IP的哈希值对应到哈希环上</span><br><span class="line">        // 定义服务器ip</span><br><span class="line">        String[] tomcatServers = new String[]&#123;&quot;123.111.0.0&quot;,&quot;123.101.3.1&quot;,&quot;111.20.35.2&quot;,&quot;123.98.26.3&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        SortedMap&lt;Integer,String&gt; hashServerMap = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(String tomcatServer: tomcatServers) &#123;</span><br><span class="line">            // 求出每一个ip的hash值，对应到hash环上，存储hash值与ip的对应关系</span><br><span class="line">            int serverHash = Math.abs(tomcatServer.hashCode());</span><br><span class="line">            // 存储hash值与ip的对应关系</span><br><span class="line">            hashServerMap.put(serverHash,tomcatServer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //step2 针对客户端IP求出hash值</span><br><span class="line">        // 定义客户端IP</span><br><span class="line">        String[] clients = new String[]&#123;&quot;10.78.12.3&quot;,&quot;113.25.63.1&quot;,&quot;126.12.3.8&quot;&#125;;</span><br><span class="line">        for(String client : clients) &#123;</span><br><span class="line">            int clientHash = Math.abs(client.hashCode());</span><br><span class="line">            //step3 针对客户端,找到能够处理当前客户端请求的服务器（哈希环上顺时针最近）</span><br><span class="line">            // 根据客户端ip的哈希值去找出哪一个服务器节点能够处理（）</span><br><span class="line">            SortedMap&lt;Integer, String&gt; integerStringSortedMap = hashServerMap.tailMap(clientHash);</span><br><span class="line">            if(integerStringSortedMap.isEmpty()) &#123;</span><br><span class="line">                // 取哈希环上的顺时针第一台服务器</span><br><span class="line">                Integer firstKey = hashServerMap.firstKey();</span><br><span class="line">                System.out.println(&quot;==========&gt;&gt;&gt;&gt;客户端：&quot; + client + &quot; 被路由到服务器：&quot; + hashServerMap.get(firstKey));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                Integer firstKey = integerStringSortedMap.firstKey();</span><br><span class="line">                System.out.println(&quot;==========&gt;&gt;&gt;&gt;客户端：&quot; + client + &quot; 被路由到服务器：&quot; + hashServerMap.get(firstKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）一致性hash算法带虚拟节点"><a href="#（三）一致性hash算法带虚拟节点" class="headerlink" title="（三）一致性hash算法带虚拟节点"></a>（三）一致性hash算法带虚拟节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsistentHashWithVirtual &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //step1 初始化：把服务器节点IP的哈希值对应到哈希环上</span><br><span class="line">        // 定义服务器ip</span><br><span class="line">        String[] tomcatServers = new String[]&#123;&quot;123.111.0.0&quot;,&quot;123.101.3.1&quot;,&quot;111.20.35.2&quot;,&quot;123.98.26.3&quot;&#125;;</span><br><span class="line">        SortedMap&lt;Integer,String&gt; hashServerMap = new TreeMap&lt;&gt;();</span><br><span class="line">        // 定义针对每个真实服务器虚拟出来几个节点</span><br><span class="line">        int virtaulCount = 3;</span><br><span class="line">        for(String tomcatServer: tomcatServers) &#123;</span><br><span class="line">            // 求出每一个ip的hash值，对应到hash环上，存储hash值与ip的对应关系</span><br><span class="line">            int serverHash = Math.abs(tomcatServer.hashCode());</span><br><span class="line">            // 存储hash值与ip的对应关系</span><br><span class="line">            hashServerMap.put(serverHash,tomcatServer);</span><br><span class="line"></span><br><span class="line">            // 处理虚拟节点</span><br><span class="line">            for(int i = 0; i &lt; virtaulCount; i++) &#123;</span><br><span class="line">                int virtualHash = Math.abs((tomcatServer + &quot;#&quot; + i).hashCode());</span><br><span class="line">                hashServerMap.put(virtualHash,&quot;----由虚拟节点&quot;+ i  + &quot;映射过来的请求：&quot;+ tomcatServer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //step2 针对客户端IP求出hash值</span><br><span class="line">        // 定义客户端IP</span><br><span class="line">        String[] clients = new String[]&#123;&quot;10.78.12.3&quot;,&quot;113.25.63.1&quot;,&quot;126.12.3.8&quot;&#125;;</span><br><span class="line">        for(String client : clients) &#123;</span><br><span class="line">            int clientHash = Math.abs(client.hashCode());</span><br><span class="line">            //step3 针对客户端,找到能够处理当前客户端请求的服务器（哈希环上顺时针最近）</span><br><span class="line">            // 根据客户端ip的哈希值去找出哪一个服务器节点能够处理（）</span><br><span class="line">            SortedMap&lt;Integer, String&gt; integerStringSortedMap = hashServerMap.tailMap(clientHash);</span><br><span class="line">            if(integerStringSortedMap.isEmpty()) &#123;</span><br><span class="line">                // 取哈希环上的顺时针第一台服务器</span><br><span class="line">                Integer firstKey = hashServerMap.firstKey();</span><br><span class="line">                System.out.println(&quot;==========&gt;&gt;&gt;&gt;客户端：&quot; + client + &quot; 被路由到服务器：&quot; + hashServerMap.get(firstKey));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                Integer firstKey = integerStringSortedMap.firstKey();</span><br><span class="line">                System.out.println(&quot;==========&gt;&gt;&gt;&gt;客户端：&quot; + client + &quot; 被路由到服务器：&quot; + hashServerMap.get(firstKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、Nginx负载均衡策略应用一致性哈希算法"><a href="#三、Nginx负载均衡策略应用一致性哈希算法" class="headerlink" title="三、Nginx负载均衡策略应用一致性哈希算法"></a>三、Nginx负载均衡策略应用一致性哈希算法</h1><p>ngx_http_upstream_consistent_hash 模块是⼀个负载均衡器，使⽤⼀个内部⼀致性hash算法来选择合适的后端节点。</p>
<p>该模块可以根据配置参数采取不同的⽅式将请求均匀映射到后端机器，</p>
<ol>
<li>consistent_hash $remote_addr：可以根据客户端ip映射</li>
<li>consistent_hash $request_uri：根据客户端请求的uri映射</li>
<li>consistent_hash $args：根据客户端携带的参数进⾏映</li>
</ol>
<h2 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h2><p>ngx_http_upstream_consistent_hash 模块是⼀个第三⽅模块，需要我们下载安装后使⽤  </p>
<p>github下载nginx⼀致性hash负载均衡模块 <a href="https://github.com/replay/ngx_http_consistent_hash">https://github.com/replay/ngx_http_consistent_hash</a>  </p>
<p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120110523081.png" alt="image-20211120110523081"></p>
<h2 id="2、将下载的压缩包上传到nginx服务器，并解压"><a href="#2、将下载的压缩包上传到nginx服务器，并解压" class="headerlink" title="2、将下载的压缩包上传到nginx服务器，并解压"></a>2、将下载的压缩包上传到nginx服务器，并解压</h2><h2 id="3）我们已经编译安装过nginx，此时进⼊当时nginx的源码⽬录，执⾏如下命令"><a href="#3）我们已经编译安装过nginx，此时进⼊当时nginx的源码⽬录，执⾏如下命令" class="headerlink" title="3）我们已经编译安装过nginx，此时进⼊当时nginx的源码⽬录，执⾏如下命令"></a>3）我们已经编译安装过nginx，此时进⼊当时nginx的源码⽬录，执⾏如下命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure —add-module=/root/ngx_http_consistent_hash-master</span><br><span class="line">make</span><br><span class="line">make install  </span><br></pre></td></tr></table></figure>

<h2 id="4）-Nginx就可以使⽤啦，在nginx-conf⽂件中配置"><a href="#4）-Nginx就可以使⽤啦，在nginx-conf⽂件中配置" class="headerlink" title="4） Nginx就可以使⽤啦，在nginx.conf⽂件中配置"></a>4） Nginx就可以使⽤啦，在nginx.conf⽂件中配置</h2><p><img src="/2021/11/20/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9C%A8Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/image-20211120110556554.png" alt="image-20211120110556554"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>nginx</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器软件分类</title>
    <url>/2021/11/17/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>b博文主要对服务器进行分类，以及一些常用的服务器软件分类，能够帮助理解系统的部署方式等~</p>
<span id="more"></span>

<h1 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h1><h2 id="1、静态和动态服务"><a href="#1、静态和动态服务" class="headerlink" title="1、静态和动态服务"></a>1、静态和动态服务</h2><h3 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h3><p>主要是提供静态资源、不同的用户访问服务得到的资源是一摸一样的</p>
<h3 id="动态服务"><a href="#动态服务" class="headerlink" title="动态服务"></a>动态服务</h3><p>提供动态服务，不同用户访问得到的资源是不同的，例如后台系统，根据每个用户身份不同，返回的结果权限都是不同的</p>
<h2 id="2、服务器分类"><a href="#2、服务器分类" class="headerlink" title="2、服务器分类"></a>2、服务器分类</h2><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>广义上来说，就是响应用户的需求，提供服务，当下所有的服务器软件都可以称之为web服务器软件，现在的web服务器应用层通讯协议主要是http协议，web服务器和http服务器几乎对等</p>
<h3 id="HTTP服务器（静态服务）"><a href="#HTTP服务器（静态服务）" class="headerlink" title="HTTP服务器（静态服务）"></a>HTTP服务器（静态服务）</h3><p>使用http协议将服务器上的资源传给客户端，侧重于静态资源的支持，可将其视为静态服务器</p>
<h3 id="应用服务器（动态服务）"><a href="#应用服务器（动态服务）" class="headerlink" title="应用服务器（动态服务）"></a>应用服务器（动态服务）</h3><p>一个特定应用的承载容器，运行时需要特定环境的支持，例如tomcat运行时需要java的支持，也可以称作动态服务器、动态容器等。应用服务器可以降维，当静态服务器使用，但一般不会这么用</p>
<h2 id="3、一些常见的服务器软件"><a href="#3、一些常见的服务器软件" class="headerlink" title="3、一些常见的服务器软件"></a>3、一些常见的服务器软件</h2><h3 id="1-Http静态服务器软件"><a href="#1-Http静态服务器软件" class="headerlink" title="1.Http静态服务器软件"></a>1.Http静态服务器软件</h3><h4 id="（一）Nginx"><a href="#（一）Nginx" class="headerlink" title="（一）Nginx"></a>（一）Nginx</h4><p>典型的静态服务器，可以做反向代理，负载均衡，一般放在最前面直面客户，和动态应用服务器例如tomcat打配合；纯C语言编写，性能贼高，内存消耗极少，稳定性也相当好，互联网公司重度使用。Nginx服务器也可以在诸如Lua脚本等辅助下做二次开发，变成一个可以提供动态服务的应用服务器，也就是大名鼎鼎的OpenRestyTengineApcheHttp Service</p>
<h4 id="（二）Tengine"><a href="#（二）Tengine" class="headerlink" title="（二）Tengine"></a>（二）Tengine</h4><p>阿里出品，基于Nginx服务器做的改造（加强和封装），对大流量场景做了很多高级功能，性能、稳定性优秀</p>
<h4 id="（三）Apache-Http-Server"><a href="#（三）Apache-Http-Server" class="headerlink" title="（三）Apache Http Server"></a>（三）Apache Http Server</h4><p>也是静态服务器，但是不如Nginx服务器</p>
<h4 id="（四）IIS"><a href="#（四）IIS" class="headerlink" title="（四）IIS"></a>（四）IIS</h4><p>微软开发，只能用在Windows下，是具备一定应用服务器能力的http服务器</p>
<h3 id="2-动态应用服务器"><a href="#2-动态应用服务器" class="headerlink" title="2.动态应用服务器"></a>2.动态应用服务器</h3><h4 id="一、轻量级动态应用服务器"><a href="#一、轻量级动态应用服务器" class="headerlink" title="一、轻量级动态应用服务器"></a>一、轻量级动态应用服务器</h4><h5 id="（一）Tomcat"><a href="#（一）Tomcat" class="headerlink" title="（一）Tomcat"></a>（一）Tomcat</h5><p>Apach出品，典型的应用服务器软件，符合Servlet标准的应用容器，也可以提供http服务，一般不会作为Http服务器去用，SpringBoot框架默认的内置服务器</p>
<h5 id="（二）Jetty"><a href="#（二）Jetty" class="headerlink" title="（二）Jetty"></a>（二）Jetty</h5><p>跟Tomcat是一个性质的东西，符合Servlet标准的应用容器，更加轻量</p>
<h5 id="（三）Undertow"><a href="#（三）Undertow" class="headerlink" title="（三）Undertow"></a>（三）Undertow</h5><p>红帽子出品，更tomcat、jetty一样也是SpringBoot框架支持的服务器，高并发时性能要优于Tomcat、Jetty</p>
<h4 id="二、商用的重量级服务器软件"><a href="#二、商用的重量级服务器软件" class="headerlink" title="二、商用的重量级服务器软件"></a>二、商用的重量级服务器软件</h4><h5 id="（一）JBoss"><a href="#（一）JBoss" class="headerlink" title="（一）JBoss"></a>（一）JBoss</h5><p>(从8版开始更名未WildFly):不仅仅是Servlet应用容器，更是EJB时的应用容器，整套JavaEE框架部署的解决方案</p>
<h5 id="（二）WebLogic"><a href="#（二）WebLogic" class="headerlink" title="（二）WebLogic"></a>（二）WebLogic</h5><p>Oracle公司出品，用于部署企业级JavaEE应用，全能型，几乎支持JavaEE所有应用规范</p>
<h5 id="（三）WebSphere"><a href="#（三）WebSphere" class="headerlink" title="（三）WebSphere"></a>（三）WebSphere</h5><p>IBM公司出品，支持更多JavaEE的应用规范的综合应用服务器</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习笔记</title>
    <url>/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这篇博文比较清晰的介绍了Nginx的相关概念和应用，主要包括动静分离、反向代理、负载均衡等相关功能实现</p>
<span id="more"></span>

<h1 id="一、Nginx基础概念理解"><a href="#一、Nginx基础概念理解" class="headerlink" title="一、Nginx基础概念理解"></a>一、Nginx基础概念理解</h1><h2 id="1、Nginx是什么"><a href="#1、Nginx是什么" class="headerlink" title="1、Nginx是什么"></a>1、Nginx是什么</h2><p>Nginx是一个高性能的HTTP和反向代理Web服务器，核心特点是占用内存少，并发能力强</p>
<h2 id="2、Nginx能做什么"><a href="#2、Nginx能做什么" class="headerlink" title="2、Nginx能做什么"></a>2、Nginx能做什么</h2><h3 id="（一）HTTP服务器（Web服务器）"><a href="#（一）HTTP服务器（Web服务器）" class="headerlink" title="（一）HTTP服务器（Web服务器）"></a>（一）HTTP服务器（Web服务器）</h3><p>关于服务器的分类可以参考文章</p>
<p>Nginx做Web服务器性能非常高，非常注重效率，能够经受高负载的考研</p>
<p>⽀持50000个并发连接数，不仅如此， CPU和内存的占⽤也⾮常的低， 10000个没有活动的连<br>接才占⽤2.5M的内存。  </p>
<h3 id="（二）反向代理服务器"><a href="#（二）反向代理服务器" class="headerlink" title="（二）反向代理服务器"></a>（二）反向代理服务器</h3><h4 id="1、正向代理"><a href="#1、正向代理" class="headerlink" title="1、正向代理"></a>1、正向代理</h4><p>​        在浏览器中配置代理服务器的相关信息，通过代理服务器访问⽬标⽹站，代理服务器收<br>到⽬标⽹站的响应之后，会把响应信息返回给我们⾃⼰的浏览器客户端  </p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211117143711172.png" alt="image-20211117143711172"></p>
<h4 id="2、反向代理"><a href="#2、反向代理" class="headerlink" title="2、反向代理"></a>2、反向代理</h4><p>​    浏览器客户端发送请求到反向代理服务器（⽐如Nginx），由反向代理服务器选择原始<br>服务器提供服务获取结果响应，最终再返回给客户端浏览器  </p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211117144945239.png" alt="image-20211117144945239"></p>
<h4 id="3、正向代理和反向代理的区别"><a href="#3、正向代理和反向代理的区别" class="headerlink" title="3、正向代理和反向代理的区别"></a>3、正向代理和反向代理的区别</h4><blockquote>
<p>维基百科：正向代理是客户端和其他所有服务器（重点：所有）的代理者，而反向代理是客户端和<strong>所要</strong>代理的服务器之间的代理</p>
</blockquote>
<p>解释一下：</p>
<p>当我们要访问google，需要一台代理服务器，只要能够连接到这台服务器的软件，就可以通过这台代理服务器器访问其他的服务器（例如goole,facebook等），这里的服务器只对客户端负责，所以称之为正向代理。</p>
<p>如果我们有3台服务器交由代理服务器进行反向代理，只有当客户端访问这3台服务器的时候，代理服务器才给客户端代理，也就是说代理服务器只对所代理的服务器负责，所以称之为反向代理。</p>
<p>总结：<strong>正向代理对客户端负责，反向代理对代理的服务器负责，一正一反。</strong></p>
<h3 id="（三）负载均衡服务器"><a href="#（三）负载均衡服务器" class="headerlink" title="（三）负载均衡服务器"></a>（三）负载均衡服务器</h3><p>负载均衡，当⼀个请求到来的时候（结合上图）， Nginx反向代理服务器根据请求去找到⼀个<br>原始服务器来处理当前请求，那么这叫做反向代理。那么，如果⽬标服务器有多台（⽐如上<br>图中的tomcat1， tomcat2， tomcat3…），找哪⼀个⽬标服务器来处理当前请求呢，这样⼀<br>个寻找确定的过程就叫做负载均衡。<br>⽣活中也有很多这样的例⼦，⽐如，我们去银⾏，可以处理业务的窗⼝有多个，那么我们会<br>被分配到哪个窗⼝呢到底，这样的⼀个过程就叫做负载均衡。  </p>
<p>负载均衡就是为了解决⾼负载的问题。  </p>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211117145049890.png" alt="image-20211117145049890"></p>
<h2 id="3、Nginx的特点"><a href="#3、Nginx的特点" class="headerlink" title="3、Nginx的特点"></a>3、Nginx的特点</h2><h3 id="（一）跨平台"><a href="#（一）跨平台" class="headerlink" title="（一）跨平台"></a>（一）跨平台</h3><p>Nginx可以在⼤多数类unix操作系统上编译运⾏，⽽且也有windows版本  </p>
<h3 id="（二）操作简单"><a href="#（二）操作简单" class="headerlink" title="（二）操作简单"></a>（二）操作简单</h3><p>Nginx的上⼿⾮常容易，配置也⽐较简单  </p>
<h3 id="（三）性能强"><a href="#（三）性能强" class="headerlink" title="（三）性能强"></a>（三）性能强</h3><p>⾼并发，性能好 ，稳定性也特别好，宕机概率很低  </p>
<h1 id="二、Nginx操作"><a href="#二、Nginx操作" class="headerlink" title="二、Nginx操作"></a>二、Nginx操作</h1><h2 id="1、Nginx的安装"><a href="#1、Nginx的安装" class="headerlink" title="1、Nginx的安装"></a>1、Nginx的安装</h2><h3 id="（一）下载"><a href="#（一）下载" class="headerlink" title="（一）下载"></a>（一）下载</h3><p>上传nginx安装包到linux服务器， nginx安装包(.tar⽂件)下载地址：  <a href="http://nginx.org/">http://nginx.org</a>  </p>
<h3 id="（二）安装依赖"><a href="#（二）安装依赖" class="headerlink" title="（二）安装依赖"></a>（二）安装依赖</h3><p>安装Nginx依赖， pcre、 openssl、 gcc、 zlib（推荐使⽤yum源⾃动安装）  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="（三）解压安装"><a href="#（三）解压安装" class="headerlink" title="（三）解压安装"></a>（三）解压安装</h3><p>解压Nginx软件包  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvf nginx-1.17.8.tar</span><br></pre></td></tr></table></figure>

<p>进⼊解压之后的⽬录 nginx-1.17.8 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd nginx-1.17.8</span><br></pre></td></tr></table></figure>

<p> 命令⾏执⾏./configure<br>命令⾏执⾏ make<br>命令⾏执⾏ make install，完毕之后在/usr/local/下会产⽣⼀个nginx⽬录  </p>
<p>进⼊sbin⽬录中，执⾏启动nginx命令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">cd nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118100118368.png" alt="image-20211118100118368"></p>
<p>然后访问服务器的80端⼝（nginx默认监听80端⼝）  </p>
<h3 id="（四）Nginx的主要命令"><a href="#（四）Nginx的主要命令" class="headerlink" title="（四）Nginx的主要命令"></a>（四）Nginx的主要命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx 启动nginx</span><br><span class="line">./nginx -s stop 终⽌nginx（当然也可以找到nginx进程号，然后使⽤kill -9 杀掉nginx进程）</span><br><span class="line">./nginx -s reload (重新加载nginx.conf配置⽂件)</span><br></pre></td></tr></table></figure>

<h1 id="三、核心配置文件解读"><a href="#三、核心配置文件解读" class="headerlink" title="三、核心配置文件解读"></a>三、核心配置文件解读</h1><p>Nginx的核⼼配置⽂件conf/nginx.conf包含三块内容：全局块、 events块、 http块  </p>
<h2 id="1、全局块"><a href="#1、全局块" class="headerlink" title="1、全局块"></a>1、全局块</h2><p>从配置⽂件开始到events块之间的内容，此处的配置影响nginx服务器整体的运⾏，⽐如worker进<br>程的数量、错误⽇志的位置等  </p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118100354343.png" alt="image-20211118100354343"></p>
<h2 id="2、events块"><a href="#2、events块" class="headerlink" title="2、events块"></a>2、events块</h2><p>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个<br>workderprocess⽀持的最⼤连接数为1024  </p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118100415321.png" alt="image-20211118100415321"></p>
<h2 id="3、http块"><a href="#3、http块" class="headerlink" title="3、http块"></a>3、http块</h2><p>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡<br>等  </p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118100438064.png" alt="image-20211118100438064"></p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118100459886.png" alt="image-20211118100459886"></p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118100520447.png" alt="image-20211118100520447"></p>
<h1 id="四、Nginx应用场景之反向代理"><a href="#四、Nginx应用场景之反向代理" class="headerlink" title="四、Nginx应用场景之反向代理"></a>四、Nginx应用场景之反向代理</h1><h2 id="1、需求一"><a href="#1、需求一" class="headerlink" title="1、需求一"></a>1、需求一</h2><h3 id="（一）需求描述"><a href="#（一）需求描述" class="headerlink" title="（一）需求描述"></a>（一）需求描述</h3><p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118105028881.png" alt="image-20211118105028881"></p>
<h3 id="（二）需求实现"><a href="#（二）需求实现" class="headerlink" title="（二）需求实现"></a>（二）需求实现</h3><ol>
<li><p>部署tomcat，保持默认监听8080端⼝  </p>
</li>
<li><p>修改nginx配置，并重新加载  </p>
</li>
<li><p>修改nginx配置  </p>
</li>
</ol>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118105211960.png" alt="image-20211118105211960"></p>
<ol start="4">
<li>重新加载nginx配置  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试，访问<a href="http://111.229.248.243:9003,返回tomcat的⻚⾯">http://111.229.248.243:9003,返回tomcat的⻚⾯</a>  </li>
</ol>
<h2 id="2、需求二"><a href="#2、需求二" class="headerlink" title="2、需求二"></a>2、需求二</h2><h3 id="（一）需求描述-1"><a href="#（一）需求描述-1" class="headerlink" title="（一）需求描述"></a>（一）需求描述</h3><p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118105355992.png" alt="image-20211118105355992"></p>
<h3 id="（二）需求实现-1"><a href="#（二）需求实现-1" class="headerlink" title="（二）需求实现"></a>（二）需求实现</h3><ol>
<li>再部署⼀台tomcat，保持默认监听8081端⼝  </li>
<li>修改nginx配置，并重新加载  </li>
</ol>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118105737970.png" alt="image-20211118105737970"></p>
<ol>
<li><p><strong>这⾥主要就是多location的使⽤，这⾥的nginx中server/location就好⽐tomcat中的 Host/Context</strong>  </p>
</li>
<li><p>location 语法如下：  </p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location [=|~|~*|^~] /uri/ &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>在nginx配置⽂件中， location主要有这⼏种形式：  </p>
<ol>
<li>正则匹配 location ~ /lagou { }</li>
<li>不区分⼤⼩写的正则匹配 location ~* /lagou { }</li>
<li>匹配路径的前缀 location ^~ /lagou { }</li>
<li>精确匹配 location = /lagou { }</li>
<li>普通路径前缀匹配 location /lagou { }</li>
<li>优先级<br>4 &gt; 3 &gt; 2 &gt; 1 &gt; 5  </li>
</ol>
<h1 id="五、Nginx应用场景之负载均衡"><a href="#五、Nginx应用场景之负载均衡" class="headerlink" title="五、Nginx应用场景之负载均衡"></a>五、Nginx应用场景之负载均衡</h1><h2 id="1、需求描述"><a href="#1、需求描述" class="headerlink" title="1、需求描述"></a>1、需求描述</h2><p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118105825319.png" alt="image-20211118105825319"></p>
<h2 id="2、Nginx负载均衡策略"><a href="#2、Nginx负载均衡策略" class="headerlink" title="2、Nginx负载均衡策略"></a>2、Nginx负载均衡策略</h2><h3 id="（一）轮询"><a href="#（一）轮询" class="headerlink" title="（一）轮询"></a>（一）轮询</h3><p>默认策略，每个请求按时间顺序逐⼀分配到不同的服务器，如果某⼀个服务器下线，能⾃动剔除  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream lagouServer&#123;</span><br><span class="line">	server 111.229.248.243:8080;</span><br><span class="line">	server 111.229.248.243:8082;</span><br><span class="line">&#125;</span><br><span class="line">location /abc &#123;</span><br><span class="line">	proxy_pass http://lagouServer/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（二）weight-权重"><a href="#（二）weight-权重" class="headerlink" title="（二）weight 权重"></a>（二）weight 权重</h3><p>weight代表权重，默认每⼀个负载的服务器都为1，权重越⾼那么被分配的请求越多（⽤于服务器<br>性能不均衡的场景）  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream lagouServer&#123;</span><br><span class="line">	server 111.229.248.243:8080 weight=1;</span><br><span class="line">	server 111.229.248.243:8082 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）ip-hash"><a href="#（三）ip-hash" class="headerlink" title="（三）ip_hash"></a>（三）ip_hash</h3><p>每个请求按照ip的hash结果分配，每⼀个客户端的请求会固定分配到同⼀个⽬标服务器处理，可<br>以解决session问题  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream lagouServer&#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">    server 111.229.248.243:8080;</span><br><span class="line">	server 111.229.248.243:8082;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、Nginx应⽤场景之动静分离"><a href="#六、Nginx应⽤场景之动静分离" class="headerlink" title="六、Nginx应⽤场景之动静分离"></a>六、Nginx应⽤场景之动静分离</h1><h2 id="1、思想"><a href="#1、思想" class="headerlink" title="1、思想"></a>1、思想</h2><p>动静分离就是讲动态资源和静态资源的请求处理分配到不同的服务器上，⽐较经典的组合就是<br>Nginx+Tomcat架构（Nginx处理静态资源请求， Tomcat处理动态资源请求），</p>
<p>那么其实之前的讲解中， Nginx反向代理⽬标服务器Tomcat，我们能看到⽬标服务器ROOT项⽬的index.jsp，这本身就是Tomcat在处理动态资源请求了。  </p>
<p>所以，我们只需要配置静态资源访问即可。  </p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118110231915.png" alt="image-20211118110231915"></p>
<h2 id="2、Nginx配置"><a href="#2、Nginx配置" class="headerlink" title="2、Nginx配置"></a>2、Nginx配置</h2><p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118110300079.png" alt="image-20211118110300079"></p>
<h1 id="七、Nginx底层进程机制剖析"><a href="#七、Nginx底层进程机制剖析" class="headerlink" title="七、Nginx底层进程机制剖析"></a>七、Nginx底层进程机制剖析</h1><p>Nginx启动后，以daemon多进程⽅式在后台运⾏，包括⼀个Master进程和多个Worker进程， Master<br>进程是领导，是⽼⼤， Worker进程是⼲活的⼩弟。  </p>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118110348867.png" alt="image-20211118110348867"></p>
<h2 id="1、Master进程"><a href="#1、Master进程" class="headerlink" title="1、Master进程"></a>1、Master进程</h2><p>主要是管理worker进程，⽐如：  </p>
<ol>
<li>接收外界信号向各worker进程发送信号(./nginx -s reload)  </li>
<li>监控worker进程的运⾏状态，当worker进程异常退出后Master进程会⾃动重新启动新的<br>worker进程等  </li>
</ol>
<h2 id="2、Worker进程"><a href="#2、Worker进程" class="headerlink" title="2、Worker进程"></a>2、Worker进程</h2><p>worker进程具体处理⽹络请求。多个worker进程之间是对等的，他们同等竞争来⾃客户端的请<br>求， <strong>各进程互相之间是独⽴的</strong>。⼀个请求，只可能在⼀个worker进程中处理，⼀个worker进程，<br>不可能处理其它进程的请求。 worker进程的个数是可以设置的，⼀般设置与机器cpu核数⼀致。  </p>
<h2 id="3、Nginx进程模型示意图如下"><a href="#3、Nginx进程模型示意图如下" class="headerlink" title="3、Nginx进程模型示意图如下"></a>3、Nginx进程模型示意图如下</h2><p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118110524659.png" alt="image-20211118110524659"></p>
<h4 id="一、以-nginx-s-reload-来说明nginx信号处理这部分-："><a href="#一、以-nginx-s-reload-来说明nginx信号处理这部分-：" class="headerlink" title="一、以 ./nginx -s reload 来说明nginx信号处理这部分  ："></a>一、以 ./nginx -s reload 来说明nginx信号处理这部分  ：</h4><ol>
<li>以 ./nginx -s reload 来说明nginx信号处理这部分  </li>
<li>尝试配置（⽐如修改了监听端⼝，那就尝试分配新的监听端⼝）  </li>
<li>尝试成功则使⽤新的配置，新建worker进程  </li>
<li>新建成功，给旧的worker进程发送关闭消息  </li>
<li>旧的worker进程收到信号会继续服务，直到把当前进程接收到的请求处理完毕后关闭<br>所以reload之后worker进程pid是发⽣了变化的  </li>
</ol>
<p><img src="/2021/11/17/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211118110627187.png" alt="image-20211118110627187"></p>
<h4 id="二、worker进程处理请求部分的说明"><a href="#二、worker进程处理请求部分的说明" class="headerlink" title="二、worker进程处理请求部分的说明"></a>二、worker进程处理请求部分的说明</h4><p>例如，我们监听9003端⼝，⼀个请求到来时，如果有多个worker进程，那么每个worker进程都有<br>可能处理这个链接。  </p>
<ol>
<li>master进程创建之后，会建⽴好需要监听的的socket，然后从master进程再fork出多个<br>worker进程。所以，所有worker进程的监听描述符listenfd在新连接到来时都变得可读。  </li>
<li>nginx使⽤互斥锁来保证只有⼀个workder进程能够处理请求，拿到互斥锁的那个进程注册<br>listenfd读事件，在读事件⾥调⽤accept接受该连接，然后解析、处理、返回客户端  </li>
</ol>
<h4 id="三、nginx多进程模型好处"><a href="#三、nginx多进程模型好处" class="headerlink" title="三、nginx多进程模型好处"></a>三、nginx多进程模型好处</h4><ol>
<li>每个worker进程都是独⽴的，不需要加锁，节省开销  </li>
<li>每个worker进程都是独⽴的，互不影响，⼀个异常结束，其他的照样能提供服务  </li>
<li>多进程模型为reload热部署机制提供了⽀撑  </li>
</ol>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库通用场景sql记录</title>
    <url>/2021/11/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E5%9C%BA%E6%99%AFsql%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录一些常用的sql，便于以后查询实用</p>
<span id="more"></span>



<h1 id="一、查询"><a href="#一、查询" class="headerlink" title="一、查询"></a>一、查询</h1><p>查询一张表根据某个字段值有几条重复数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 字段名 <span class="keyword">having</span> <span class="built_in">count</span>(<span class="number">1</span>)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>





<p>Oracle：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--1.获取表字段字典</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">t.COLUMN_NAME <span class="keyword">as</span> &quot;字段名&quot;,</span><br><span class="line">decode(c.COMMENTS, <span class="keyword">null</span>, <span class="string">&#x27; &#x27;</span>, c.COMMENTS) <span class="keyword">as</span> &quot;含义&quot;,</span><br><span class="line">decode(t.DATA_TYPE, <span class="string">&#x27;TIMESTAMP(6)&#x27;</span>, t.DATA_TYPE, <span class="string">&#x27;NUMBER&#x27;</span>, (t.DATA_TYPE <span class="operator">||</span> <span class="string">&#x27;(&#x27;</span> <span class="operator">||</span> t.DATA_PRECISION <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;DATE&#x27;</span>, t.DATA_TYPE, (t.DATA_TYPE <span class="operator">||</span> <span class="string">&#x27;(&#x27;</span> <span class="operator">||</span> t.CHAR_LENGTH <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span>)) <span class="keyword">as</span> &quot;长度&quot;,</span><br><span class="line"><span class="comment">-- t.DATA_TYPE || &#x27;(&#x27; || t.CHAR_LENGTH || &#x27;)&#x27; as &quot;类型(长度)&quot;,</span></span><br><span class="line"><span class="comment">--  t.CHAR_LENGTH as &quot;字段长度&quot;,</span></span><br><span class="line">t.NULLABLE <span class="keyword">AS</span> &quot;是否为空&quot;</span><br><span class="line"><span class="keyword">from</span> USER_TAB_COLUMNS t <span class="keyword">join</span> USER_COL_COMMENTS c <span class="keyword">on</span> c.TABLE_NAME <span class="operator">=</span> t.TABLE_NAME <span class="keyword">and</span> t.COLUMN_NAME <span class="operator">=</span> c.COLUMN_NAME</span><br><span class="line"><span class="keyword">where</span> c.TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;SK_COLLECT_INFO&#x27;</span> <span class="comment">--表名应该大写  </span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t.COLUMN_ID;</span><br></pre></td></tr></table></figure>



<h1 id="二、增加"><a href="#二、增加" class="headerlink" title="二、增加"></a>二、增加</h1><h1 id="三、修改"><a href="#三、修改" class="headerlink" title="三、修改"></a>三、修改</h1><p>数据表新增字段</p>
<p>Oracle：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add (字段名 VARCHAR2(500) null);</span><br><span class="line">comment on column 表名.字段名 is &#x27;二维码链接地址&#x27;;</span><br></pre></td></tr></table></figure>



<h1 id="四、删除"><a href="#四、删除" class="headerlink" title="四、删除"></a>四、删除</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程学习记录（一）</title>
    <url>/2021/11/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>以往学习多线程总是很零碎，不写就忘，然后一段时间又要翻各种资料，就打算最近写一写多线程内容，当然自己可能了解的都是基础，记录的话呢还是准备以实战为主，理论为辅</p>
<span id="more"></span>

<h1 id="一、概念理解"><a href="#一、概念理解" class="headerlink" title="一、概念理解"></a>一、概念理解</h1><h3 id="1-进程："><a href="#1-进程：" class="headerlink" title="1. 进程："></a>1. 进程：</h3><p>进程是资源分配的最小单位，是程序的一次执行过程，或是正在运行的一个程序</p>
<h3 id="2-线程："><a href="#2-线程：" class="headerlink" title="2. 线程："></a>2. 线程：</h3><p>线程是CPU调度的最小单位，是一个程序内部的一条执行路径，是进程中可独立执行的子任务</p>
<p>同一个进程中的线程共享该进程申请到的资源</p>
<h3 id="3-任务"><a href="#3-任务" class="headerlink" title="3.任务"></a>3.任务</h3><p>任务task是一个相对的概念，把线程比作员工的话，任务就是线程要完成的工作，一个文件可以算一个任务，文件中的多个记录也可以算一个任务，多个文件也可以算一个任务</p>
<h3 id="3-并行、并发"><a href="#3-并行、并发" class="headerlink" title="3. 并行、并发"></a>3. 并行、并发</h3><p>并行：多个任务在同一时间范围内被执行，这些任务往往不是顺序执行的，而是交替执行的</p>
<p>并发：多个任务在同一时刻被执行</p>
<h3 id="4-线程上下文切换"><a href="#4-线程上下文切换" class="headerlink" title="4. 线程上下文切换"></a>4. 线程上下文切换</h3><h3 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5. 线程安全"></a>5. 线程安全</h3>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>快速搭建java开发环境</title>
    <url>/2021/11/13/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>每次换电脑或者换环境开发都需要重新搭建一套java开发环境，如果有一个脚本我们点一下就能装好这一套环境是不是很nice呢~</p>
<span id="more"></span>

<h1 id="一、概念理解"><a href="#一、概念理解" class="headerlink" title="一、概念理解"></a>一、概念理解</h1><h2 id="1、首先我们要明确下通用的一套java环境包括那些："><a href="#1、首先我们要明确下通用的一套java环境包括那些：" class="headerlink" title="1、首先我们要明确下通用的一套java环境包括那些："></a>1、首先我们要明确下通用的一套java环境包括那些：</h2><ol>
<li>jdk: 这里选择使用最多的1.8版本。这里我们要明白，我们装jdk最后输出的不过就是一个文件夹，里面有java编译运行工具、jre虚拟机环境、依赖 的jar包等。所以我们直接拷贝过来一个这样的目录也是丝毫没有问题的。</li>
<li>maven: 我们下载解压出来就是一个文件目录</li>
<li>tomcat: 同样下载解压也是一个文件目录</li>
</ol>
<h2 id="2、在开搞前理解下环境变量和classpath的含义和区别"><a href="#2、在开搞前理解下环境变量和classpath的含义和区别" class="headerlink" title="2、在开搞前理解下环境变量和classpath的含义和区别"></a>2、在开搞前理解下环境变量和classpath的含义和区别</h2><h3 id="一、Path环境变量"><a href="#一、Path环境变量" class="headerlink" title="一、Path环境变量"></a>一、Path环境变量</h3><p>这么简单理解吧，我们想要找一个文件，是不是要一层一层找到它所在的文件夹下然后进去才能找到它，现在我们把它所在的文件夹路径配置到<code>Path</code>中，那么我们就可在任意目录下都能直接操作这个文件夹下的文件或者工具。</p>
<p>你想要是我们使用<code>jdk</code>中<code>bin</code>目录下的<code>javac</code>编译工具，我们把它的上级文件夹路径配到<code>Path</code>中，那么我们在任意目录下都能用<code>javac</code>和它同目录下的工具不是很方便嘛。换而言之，我们不配有什么影响吗？虽然没有，但是编译只能在<code>bin</code>这个目录下操作不觉得很麻烦吗，并且现在的编译器像<code>Eclipse</code>安装前都必须要求配置好环境变量</p>
<h3 id="二、classpath环境变量"><a href="#二、classpath环境变量" class="headerlink" title="二、classpath环境变量"></a>二、classpath环境变量</h3><p>classpath和path环境变量有什么区别呢，首先我们明白path是让指定目录下的文件在任意目录下可用，那么我们知道java在编写代码时肯定会用到一些jdk自带的工具类，我们的代码依赖这样的jar包，这个时候将我们所依赖的jar包也配置成在任意目录下可导入，是很有意义的，不然这一系列路径开发起来别提多难受了。简单理解</p>
<p>path暴漏的时工具，classpath暴漏的是代码编写所依赖的jar包</p>
<h2 id="3、那我们需要配置哪些东西呢"><a href="#3、那我们需要配置哪些东西呢" class="headerlink" title="3、那我们需要配置哪些东西呢"></a>3、那我们需要配置哪些东西呢</h2><ol>
<li>java的path环境变量</li>
<li>java的classpath环境变量</li>
<li>maven的path环境变量</li>
</ol>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p>首先我们准备这样一套文件，tomcat不需要配置环境变量，因此脚本并不需要对其进行操作</p>
<p><img src="/2021/11/13/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20211113180621148.png" alt="image-20211113180621148"></p>
<h2 id="2、编写脚本"><a href="#2、编写脚本" class="headerlink" title="2、编写脚本"></a>2、编写脚本</h2><ol>
<li>新建<strong>java开发环境搭建（管理员运行）.bat</strong>脚本，注意脚本和三个文件目录在同一级别下，并且jdk和maven文件夹进去后bin目录就在里面</li>
</ol>
<p>也可以替换不同的jdk和maven版本，替换文件夹后，修改<code>JdkFilePath</code>和<code>MavenFilePath</code>两个参数即可，值为文件夹名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:step1</span><br><span class="line">cd /d %~dp0</span><br><span class="line">set currentPATH=%PATH%</span><br><span class="line">set currentDir=%cd%</span><br><span class="line">::只需要修改这两个参数即可</span><br><span class="line">set JdkFilePath=jdk1.8.0_162</span><br><span class="line">set MavenFilePath=apache-maven-3.8.1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>脚本执行的核心操作也就是对环境变量的操作，具体为：</li>
</ol>
<p>使用<code>wmic</code> 指令，对<code>JAVA_HOME</code>、<code>MAVEN_HOME</code>、<code>CLASSPATH</code>三条变量先删除，再新建</p>
<p><img src="/2021/11/13/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20211113184028661.png" alt="image-20211113184028661"></p>
<ol start="3">
<li>然后判断Path变量有无配置JAVA_HOME、MAVEN_HOME，如果配置了就不用再操作，未配置则添加</li>
</ol>
<p><img src="/2021/11/13/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20211113184207955.png" alt="image-20211113184207955"></p>
<ol start="4">
<li>因为操作涉及到环境变量的修改，所以需要重启电脑，将在完成指令的30s后重启</li>
</ol>
<p><img src="/2021/11/13/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20211113184428829.png" alt="image-20211113184428829"></p>
<ol start="5">
<li>注意：脚本涉及环境变量的修改，执行时一定要使用管理员权限执行</li>
</ol>
<p><img src="/2021/11/13/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20211113182856443.png" alt="image-20211113182856443"></p>
<ol start="6">
<li>重启后，执行版本查看，发现已经修改成功</li>
</ol>
<p><img src="/2021/11/13/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20211113183355567.png" alt="image-20211113183355567"></p>
<h1 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h1><p>其实这个脚本没有什么别的操作，就是对环境变量的修改，还是蛮简单的，将这个文件夹打个包，传到云端，随去随用不是很方便吗~</p>
<p><a href="java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88%E7%AE%A1%E7%90%86%E5%91%98%E8%BF%90%E8%A1%8C%EF%BC%89.bat">脚本点击下载</a></p>
<p>源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">cls</span><br><span class="line"><span class="built_in">echo</span> **********************************************</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>     一   键   配   置   开   发   环   境</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>       安装请按任意键，退出直接关闭窗口</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> **********************************************</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">:step1</span><br><span class="line"><span class="built_in">cd</span> /d %~dp0</span><br><span class="line"><span class="built_in">set</span> currentPATH=%PATH%</span><br><span class="line"><span class="built_in">set</span> currentDir=%<span class="built_in">cd</span>%</span><br><span class="line">::只需要修改这两个参数即可</span><br><span class="line"><span class="built_in">set</span> JdkFilePath=jdk1.8.0_162</span><br><span class="line"><span class="built_in">set</span> MavenFilePath=apache-maven-3.8.1</span><br><span class="line"></span><br><span class="line">:step2</span><br><span class="line"><span class="built_in">set</span> developDir=%currentDir%</span><br><span class="line"><span class="built_in">echo</span> %developDir%</span><br><span class="line">goto step4</span><br><span class="line"></span><br><span class="line">:step4</span><br><span class="line">wmic ENVIRONMENT <span class="built_in">where</span> <span class="string">&quot;name=&#x27;JAVA_HOME&#x27;&quot;</span> delete</span><br><span class="line">wmic ENVIRONMENT create name=<span class="string">&quot;JAVA_HOME&quot;</span>,username=<span class="string">&quot;&lt;system&gt;&quot;</span>,VariableValue=<span class="string">&quot;%developDir%\%JdkFilePath%&quot;</span></span><br><span class="line">wmic ENVIRONMENT <span class="built_in">where</span> <span class="string">&quot;name=&#x27;MAVEN_HOME&#x27;&quot;</span> delete</span><br><span class="line">wmic ENVIRONMENT create name=<span class="string">&quot;MAVEN_HOME&quot;</span>,username=<span class="string">&quot;&lt;system&gt;&quot;</span>,VariableValue=<span class="string">&quot;%developDir%\%MavenFilePath%&quot;</span></span><br><span class="line">wmic ENVIRONMENT <span class="built_in">where</span> <span class="string">&quot;name=&#x27;CLASSPATH&#x27;&quot;</span> delete</span><br><span class="line">wmic ENVIRONMENT create name=<span class="string">&quot;CLASSPATH&quot;</span>,username=<span class="string">&quot;&lt;system&gt;&quot;</span>,VariableValue=<span class="string">&quot;.;%%JAVA_HOME%%\lib\toos.jar;%%JAVA_HOME%%\lib\dt.jar&quot;</span></span><br><span class="line"><span class="built_in">echo</span> JAVA_HOME:%developDir%\%JdkFilePath%</span><br><span class="line"><span class="built_in">echo</span> MAVEN_HOME:%developDir%\%MavenFilePath%</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">goto step7</span><br><span class="line"></span><br><span class="line">:step7</span><br><span class="line">wmic ENVIRONMENT <span class="built_in">where</span> <span class="string">&quot;name=&#x27;Path&#x27;&quot;</span> get VariableValue|findstr /i /c:<span class="string">&quot;%%JAVA_HOME%%\bin&quot;</span>&gt;nul&amp;&amp;(goto step5)  </span><br><span class="line"><span class="built_in">echo</span> PATH环境变量中未添加: %JAVA_HOME%\bin </span><br><span class="line">wmic ENVIRONMENT <span class="built_in">where</span> <span class="string">&quot;name=&#x27;Path&#x27; and username=&#x27;&lt;system&gt;&#x27;&quot;</span> <span class="built_in">set</span> VariableValue=<span class="string">&quot;%currentPATH%;%%JAVA_HOME%%\bin&quot;</span></span><br><span class="line"><span class="built_in">set</span> currentPATH=%currentPATH%;%%JAVA_HOME%%\bin</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line">:step5</span><br><span class="line"><span class="built_in">echo</span> JAVA_HOME PATH中已添加</span><br><span class="line">wmic ENVIRONMENT <span class="built_in">where</span> <span class="string">&quot;name=&#x27;Path&#x27;&quot;</span> get VariableValue|findstr /i /c:<span class="string">&quot;%%MAVEN_HOME%%\bin&quot;</span>&gt;nul&amp;&amp;(goto step6)  </span><br><span class="line"><span class="built_in">echo</span> PATH环境变量中未添加: %MAVEN_HOME%\bin </span><br><span class="line">wmic ENVIRONMENT <span class="built_in">where</span> <span class="string">&quot;name=&#x27;Path&#x27; and username=&#x27;&lt;system&gt;&#x27;&quot;</span> <span class="built_in">set</span> VariableValue=<span class="string">&quot;%currentPATH%;%%MAVEN_HOME%%\bin&quot;</span></span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"></span><br><span class="line">:step6</span><br><span class="line"><span class="built_in">echo</span> MAVEN_HOME PATH中已添加</span><br><span class="line"></span><br><span class="line">:step8</span><br><span class="line"><span class="built_in">echo</span> 电脑将在30秒内重启，请做好保存工作，按任意键继续...</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">shutdown -r -t 30</span><br><span class="line">:<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">@<span class="built_in">echo</span>.</span><br><span class="line">:end</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>bat</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>编写脚本一键部署发布博文（二）</title>
    <url>/2021/11/13/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>上一篇一键发布脚本写好了，但是感觉还是不够方便，所以又进行了一番优化，优化的点主要有以下几方面</p>
<ol>
<li>脚本支持<strong>新增博文</strong>功能，只需输入要新建的文章名称，<strong>自动创建博客文章</strong>，<strong>并且会自动运行</strong><code>typora</code>编辑器打开这篇新增博文</li>
<li><strong>支持重复</strong><code>clean</code>、<code>generate</code>，有时候一次clean编译会由于文件正在使用或者其他原因没有成功，这时我们肯定不希望脚本就此停止了，而是再解决完问题后在这次执行中继续<code>clean</code>,编译</li>
<li><strong>支持本地运行</strong>，可以通过输入选项来开启本地预览</li>
<li>支持<strong>单独部署</strong>到<code>GitHub</code>上，解决上一个博客每次部署前都会clean编译问题,有时并不需要</li>
<li>支持部署到<code>GitHub</code>后的同时，开启本地预览</li>
</ol>
<p>哈哈哈~~至此，是不是觉得这个脚本功能还是挺全的</p>
<span id="more"></span>    

<h1 id="一、脚本整体架构"><a href="#一、脚本整体架构" class="headerlink" title="一、脚本整体架构"></a>一、脚本整体架构</h1><ol>
<li>脚本采用类似Java中Switch-Case的语法，通过输入的指令来进行对应功能执行</li>
</ol>
<p><img src="/2021/11/13/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%BA%8C%EF%BC%89/image-20211113113033319.png" alt="image-20211113113033319"></p>
<ol start="2">
<li>脚本可复用性提高，只需要修改几个参数即可实现拿来即用，几个参数均放置在脚本内容上方</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::此处配置编译器路径，自定义调整</span><br><span class="line">set idePath=&quot;D:\installsoftware\Typora\Typora&quot;</span><br><span class="line"></span><br><span class="line">::此处配置编译器名称，搭配上一条调整</span><br><span class="line">set ideName=&quot;Typora.exe&quot;</span><br><span class="line"></span><br><span class="line">::博客根目录</span><br><span class="line">set blogRootPath=&quot;D:\blog&quot;</span><br><span class="line"></span><br><span class="line">::博文所在目录</span><br><span class="line">set blogSrcPath=&quot;%blogRootPath%\source\_posts&quot;</span><br></pre></td></tr></table></figure>



<h1 id="二、具体功能"><a href="#二、具体功能" class="headerlink" title="二、具体功能"></a>二、具体功能</h1><h2 id="1、新增博文"><a href="#1、新增博文" class="headerlink" title="1、新增博文"></a>1、新增博文</h2><p>核心代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::新建博文并编辑</span><br><span class="line">:step4</span><br><span class="line">set /p name=input name:</span><br><span class="line">echo name:%name%</span><br><span class="line">echo please wait</span><br><span class="line">call hexo new post %name%</span><br><span class="line">call start /d &quot;%idePath%&quot; %ideName% &quot;%blogSrcPath%\%name%.md&quot;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<ol>
<li>主要是接收一个博文名称，执行hexo new &lt;name&gt; 指令新增博文</li>
<li>使用<code>start</code>指令运行typora可执行文件打开这篇已创建的博文</li>
</ol>
<h2 id="2、单独部署到GitHub"><a href="#2、单独部署到GitHub" class="headerlink" title="2、单独部署到GitHub"></a>2、单独部署到GitHub</h2><p>这个功能没有什么，就是输入指令，然后运行了对应的<code>hexo -d</code> 指令</p>
<h2 id="3、可重复clean-编译"><a href="#3、可重复clean-编译" class="headerlink" title="3、可重复clean 编译"></a>3、可重复clean 编译</h2><p>哈哈哈，这地方取了个巧，就是在<code>clean</code>,<code>generate</code> 之后，使用goto指令再次指向功能菜单那一步骤</p>
<h2 id="4、可单独本地预览"><a href="#4、可单独本地预览" class="headerlink" title="4、可单独本地预览"></a>4、可单独本地预览</h2><p>这…可不就是把第二步拿来替换了个指令嘛<code>hexo s</code></p>
<h1 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h1><p>整体看上去没什么技术含量，实际上确实没有，哈哈哈，只是把功能做了个整合。有兴趣的朋友可以试一试哈哈哈</p>
<p><a href="hexoopt.bat">完成版脚本下载点击</a></p>
<p>源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">cls</span><br><span class="line"><span class="built_in">echo</span> **********************************************</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>       hexo  新  增 - 预  览 - 发   布       </span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>       安装请按任意键，退出直接关闭窗口</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> **********************************************</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">::此处配置编译器路径，自定义调整</span><br><span class="line"><span class="built_in">set</span> idePath=<span class="string">&quot;D:\installsoftware\Typora\Typora&quot;</span></span><br><span class="line">::此处配置编译器名称，搭配上一条调整</span><br><span class="line"><span class="built_in">set</span> ideName=<span class="string">&quot;Typora.exe&quot;</span></span><br><span class="line"></span><br><span class="line">::博客根目录</span><br><span class="line"><span class="built_in">set</span> blogRootPath=<span class="string">&quot;D:\blog&quot;</span></span><br><span class="line">::博文所在目录</span><br><span class="line"><span class="built_in">set</span> blogSrcPath=<span class="string">&quot;%blogRootPath%\source\_posts&quot;</span></span><br><span class="line"></span><br><span class="line">::切换到博客根目录</span><br><span class="line"><span class="built_in">cd</span> /d %blogRootPath%</span><br><span class="line"></span><br><span class="line">:step1</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> C:新建博文并编辑</span><br><span class="line"><span class="built_in">echo</span> R:重新clean并构建</span><br><span class="line"><span class="built_in">echo</span> S:本地预览</span><br><span class="line"><span class="built_in">echo</span> D:部署到GitHub</span><br><span class="line"><span class="built_in">echo</span> E:结束执行</span><br><span class="line"><span class="built_in">echo</span> A:部署到GitHub后开启本地预览</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">set</span> /p o=请选择以下操作?(C R S D E A):</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%o%&quot;</span>==<span class="string">&quot;c&quot;</span> goto c</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%o%&quot;</span>==<span class="string">&quot;r&quot;</span> goto r</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%o%&quot;</span>==<span class="string">&quot;s&quot;</span> goto s</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%o%&quot;</span>==<span class="string">&quot;d&quot;</span> goto d</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%o%&quot;</span>==<span class="string">&quot;e&quot;</span> goto e</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%o%&quot;</span>==<span class="string">&quot;a&quot;</span> goto a</span><br><span class="line"></span><br><span class="line">goto step1</span><br><span class="line">:d</span><br><span class="line">call hexo d	</span><br><span class="line"><span class="built_in">echo</span>  部署到GitHub上完成...</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">:e</span><br><span class="line"><span class="built_in">echo</span> 脚本执行结束！</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">:s</span><br><span class="line">call hexo s</span><br><span class="line"><span class="built_in">echo</span>  本地启动完成...预览地址：http://localhost:4000/</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">:A</span><br><span class="line">call hexo d</span><br><span class="line"><span class="built_in">echo</span> 部署到GitHub上完成...</span><br><span class="line">call hexo s</span><br><span class="line"><span class="built_in">echo</span> 本地启动完成...预览地址：http://localhost:4000/</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">:C</span><br><span class="line">goto step4</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">:R</span><br><span class="line">goto step2</span><br><span class="line"></span><br><span class="line">::clean</span><br><span class="line">:step2</span><br><span class="line"><span class="built_in">echo</span> Please <span class="built_in">wait</span></span><br><span class="line">call hexo clean</span><br><span class="line"><span class="built_in">echo</span> clean清除完成...</span><br><span class="line"></span><br><span class="line">::generate</span><br><span class="line">:step3</span><br><span class="line">call hexo g</span><br><span class="line"><span class="built_in">echo</span> generate 构建完成...</span><br><span class="line">goto step1</span><br><span class="line"></span><br><span class="line">::新建博文并编辑</span><br><span class="line">:step4</span><br><span class="line"><span class="built_in">set</span> /p name=input name:</span><br><span class="line"><span class="built_in">echo</span> name:%name%</span><br><span class="line"><span class="built_in">echo</span> please <span class="built_in">wait</span></span><br><span class="line">call hexo new post %name%</span><br><span class="line">call start /d <span class="string">&quot;%idePath%&quot;</span> %ideName% <span class="string">&quot;%blogSrcPath%\%name%.md&quot;</span></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h1 id="四、后续优化"><a href="#四、后续优化" class="headerlink" title="四、后续优化"></a>四、后续优化</h1><p>本次优化实现了执行完hexo d部署静态文件后，执行了上传博客源文件的步骤，这样保证不经博文是最新的，博客的源文件也是最新的，换个电脑拉下来即可接着写内容，实现效果</p>
<p><img src="/2021/11/13/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%BA%8C%EF%BC%89/image-20211115015102520.png" alt="image-20211115015102520"></p>
<p>修改部分内容如下，需要的可以改在脚本上即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:d</span><br><span class="line">call hexo d	</span><br><span class="line">echo **********************************************     </span><br><span class="line">echo.</span><br><span class="line">echo       部署到GitHub上完成</span><br><span class="line">echo.</span><br><span class="line">echo **********************************************</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;提交博客源文件&quot;</span><br><span class="line">git push origin hexoSrc</span><br><span class="line">echo **********************************************     </span><br><span class="line">echo.</span><br><span class="line">echo       提交博客源文件完成</span><br><span class="line">echo.</span><br><span class="line">echo **********************************************</span><br><span class="line">pause</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>bat</tag>
        <tag>hexo</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>bat批处理脚本学习</title>
    <url>/2021/11/13/bat%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>windows使用中，当我们经常要进行一系列重复操作时，就可以考虑编写一个批处理脚本来简化批量化处理。批处理（Batch）往往以<code>.bat</code>结尾，其作用嘛：无非就是能够连续执行多条命令</p>
<span id="more"></span>

<h1 id="一、语法了解"><a href="#一、语法了解" class="headerlink" title="一、语法了解"></a>一、语法了解</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h2><h3 id="（一）bat文件变量的赋值"><a href="#（一）bat文件变量的赋值" class="headerlink" title="（一）bat文件变量的赋值"></a>（一）bat文件变量的赋值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set num=10</span><br><span class="line">set name=xiaomin</span><br></pre></td></tr></table></figure>

<h3 id="（二）bat文件变量的使用"><a href="#（二）bat文件变量的使用" class="headerlink" title="（二）bat文件变量的使用"></a>（二）bat文件变量的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo %num%</span><br><span class="line">echo %name%</span><br></pre></td></tr></table></figure>

<h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h2><h3 id="1、echo"><a href="#1、echo" class="headerlink" title="1、echo"></a>1、echo</h3><ol>
<li>ECHO [ON | OFF] 打开回显或关闭回显功能。</li>
</ol>
<p>一般bat文件第一行都是@echo off,即关闭回显功能</p>
<p>echo off 代表这行后面的命令执行时都不再输出显示命令本身，@表示显示其后面的命令，对该行生效，所以搭配起来就是脚本执行不显示命令行本身</p>
<ol start="2">
<li>另外echo具备输出和换行的功能</li>
</ol>
<img src="/2021/11/13/bat%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/image-20211114191146740.png" alt="image-20211114191146740" style="zoom: 67%;">

<h3 id="2、pause"><a href="#2、pause" class="headerlink" title="2、pause"></a>2、pause</h3><p>会暂停批处理的执行，并在屏幕上显示请按任意键继续…的提示，等待用户按任意键后继续</p>
<p>一般用来让用户考虑是否继续执行，不执行的话关掉命令窗口即可</p>
<h3 id="3、cls"><a href="#3、cls" class="headerlink" title="3、cls"></a>3、cls</h3><p>清屏，执行到该命令时之前的输出结果将会clean掉，这个clean并不是删除了什么，只是将最新行置于窗口顶部，其实再往上翻记录还是有的</p>
<h3 id="4、call"><a href="#4、call" class="headerlink" title="4、call"></a>4、call</h3><p>call [要执行的脚本路径+脚本名称] [要传递的参数]</p>
<p>调用另一个批处理程序，并且不终止父批处理程序</p>
<p>在执行完另一个脚本后仍然返回到当前的批处理程序继续执行</p>
<h3 id="5、REM"><a href="#5、REM" class="headerlink" title="5、REM"></a>5、REM</h3><p>语法：Rem Message…</p>
<p>(小技巧：用::代替rem)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::下面一行会输出hello</span><br><span class="line">echo hello</span><br></pre></td></tr></table></figure>

<h3 id="6、-p"><a href="#6、-p" class="headerlink" title="6、/p"></a>6、/p</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set /p filename=请输入文件名称</span><br><span class="line">echo %filename%</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/13/bat%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/image-20211114201532547.png" alt="image-20211114201532547"></p>
<h3 id="7、if"><a href="#7、if" class="headerlink" title="7、if"></a>7、if</h3><p>if 表示将判断是否符合规定的条件，从而决定执行不同的命令。有三种格式:</p>
<ol>
<li>语法: if [not] “参数” == “字符串” 待执行的命令</li>
</ol>
<p>参数如果等于(not表示不等，下同)指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">if &quot;111&quot;==&quot;222&quot; echo 111==222</span><br><span class="line">echo ================</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>语法: if [not] exist [路径]文件名 待执行的命令</li>
</ol>
<p><img src="/2021/11/13/bat%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/image-20211114193227622.png" alt="image-20211114193227622"></p>
<ol start="3">
<li>语法: if [not] errorlevel &lt;数字&gt; 待执行的命令</li>
</ol>
<p>很多DOS程序在运行结束后会返回一个数字值用来表示程序运行的结果(或者状态)，称为错误码errorlevel或称返回码。</p>
<p>常见的返回码为0、1。通过if errorlevel命令可以判断程序的返回值，根据不同的返回值来决定执行不同的命令。</p>
<p>**if-else if-else **</p>
<p>注意：输出的括号和条件之间要留有空格，如果要换行else ，在if行尾需要加上<code>^</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set num=1</span><br><span class="line">if %num%==0 (echo 111) else if %num%==2 (echo 222)^</span><br><span class="line">else (echo 333)	</span><br><span class="line">echo %num%</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">333</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="8、goto"><a href="#8、goto" class="headerlink" title="8、goto"></a>8、goto</h3><p>语法：goto label (label是参数，指定所要转向的批处理程序中的行。)</p>
<p>指定跳转到标签行，找到标签行后，程序将处理从下一行开始的命令。</p>
<p>label标签的名字可以随便起，但是最好是有意义的，字母前必须加个冒号“:”来表示这个字母是标签。</p>
<p>goto命令就是根据这个冒号来寻找下一步跳到到那里。经常与 if 配合使用，根据不同的条件来执行不同的命令组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">GOTO step3</span><br><span class="line">:step2</span><br><span class="line">echo step2</span><br><span class="line"></span><br><span class="line">:step3</span><br><span class="line">echo step3</span><br><span class="line"></span><br><span class="line">:step4</span><br><span class="line">echo step4</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/2021/11/13/bat%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/image-20211114202536708.png" alt="image-20211114202536708"></p>
<h3 id="9、-dp0"><a href="#9、-dp0" class="headerlink" title="9、%~dp0"></a>9、%~dp0</h3><p><code>%~dp0</code>代表脚本当前路径，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo %~dp0</span><br><span class="line">输出的结果：D:\kuaijie\</span><br><span class="line"></span><br><span class="line">%~dp0 “d”为Drive的缩写，即为驱动器，磁盘、“p”为Path缩写，即为路径，目录</span><br><span class="line"></span><br><span class="line">cd %~dp0 ：进入bat脚本所在目录</span><br><span class="line"></span><br><span class="line">cd %~dp0bin\ ：进入bat脚本所在目录的bin目录</span><br></pre></td></tr></table></figure>

<h3 id="10、脚本间参数传递"><a href="#10、脚本间参数传递" class="headerlink" title="10、脚本间参数传递"></a>10、脚本间参数传递</h3><p>%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格(或者Tab)分隔的字符串。</p>
<p>变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用 %1 到 %9 顺序表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如我执行：</span><br><span class="line">call test.bat c1 2 3 4 5 6 7 8 9 a s</span><br><span class="line"></span><br><span class="line">在test.bat脚本内部，$0=test.bat;$1=c1;$9=9;$19=c19</span><br></pre></td></tr></table></figure>

<h3 id="11、start"><a href="#11、start" class="headerlink" title="11、start"></a>11、start</h3><p>调用外部程序，所有的DOS命令和命令行程序都可由start命令来调用</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start /d &quot;D:\software&quot; typora.ext &quot;bat.md&quot;</span><br></pre></td></tr></table></figure>

<p>就可以运行d盘software目录下的typora.exe编辑器打开bat.md文件了</p>
<h3 id="12、choice"><a href="#12、choice" class="headerlink" title="12、choice"></a>12、choice</h3><p>CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]</p>
<p>描述:<br>    该工具允许用户从选择列表选择一个项目并返回所选项目的索引。</p>
<p>参数列表:<br>   /C    choices       指定要创建的选项列表。默认列表是 “YN”。</p>
<p>   /M    text          指定提示之前要显示的消息。如果没有指定，工具只显示提示。</p>
<p>   /?                  显示此帮助消息。</p>
<p>示例：</p>
<p><img src="/2021/11/13/bat%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/image-20211114195932969.png" alt="image-20211114195932969"></p>
<h3 id="13、exit-命令"><a href="#13、exit-命令" class="headerlink" title="13、exit 命令"></a>13、exit 命令</h3><p>结束程序。即时是被调用的程序，结束后也不会返回原程序</p>
<h1 id="二、小技巧"><a href="#二、小技巧" class="headerlink" title="二、小技巧"></a>二、小技巧</h1><h3 id="1、实现pause功能，自定义输出内容"><a href="#1、实现pause功能，自定义输出内容" class="headerlink" title="1、实现pause功能，自定义输出内容"></a>1、实现pause功能，自定义输出内容</h3><p>在bat文件最后实用set /p tmp=操作结束，请按回车键退出… 代替 pause</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set /p tmp=操作结束，请按回车键退出...</span><br></pre></td></tr></table></figure>

<h3 id="2、在脚本中添加chcp-65001解决中文乱码"><a href="#2、在脚本中添加chcp-65001解决中文乱码" class="headerlink" title="2、在脚本中添加chcp 65001解决中文乱码"></a>2、在脚本中添加chcp 65001解决中文乱码</h3><p>在脚本中文前方添加<code>chcp 65001</code>，cmd的编码格式就是UTF-8,仅当前脚本执行有效</p>
<p>或者把bat文件的编码改为ANSI，UTF-8在win10我这儿会中文显示乱码</p>
<h3 id="3、进入指定盘符"><a href="#3、进入指定盘符" class="headerlink" title="3、进入指定盘符"></a>3、进入指定盘符</h3><p>cmd窗口中我们往往要先输入d:切换到D盘</p>
<p>然后再cd D:\blog进入D盘下目录，其实我们可以通过cd加参数 /d来直接进入任意盘符下目录</p>
<p>cd /d d:\blog</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>bat脚本功能很多，这里只列了最最基本的一些使用，在后续实际需求中，我们可以思考用bat脚本如何提高自己的效率……</p>
]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title>编写脚本一键部署发布博文 (一)</title>
    <url>/2021/11/12/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>事情起因是每次修改了博文都要执行 <code>hexo clean</code> <code>hexo g</code> <code>hexo d</code>一套来清除，重新编译，部署完成一套操作，这对于追求极客效率的开发来说必是要想办法优化的，怎么做编写一个一键部署的脚本呢，考虑到之前还没怎么编写过bat批处理脚本，本次借着时间来尝试一下</p>
<span id="more"></span>    

<h1 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h1><p>1、执行脚本可以确认执行或者关掉窗口不执行，确认执行将依次执行<code>hexo clean</code> 和 <code>hexo g</code>指令</p>
<p>2、弹出指示询问是否部署到Github上，输入yes将部署，输入no，提示自己选择了不部署，然后关闭窗口即可</p>
<p>3、在任意界面能够执行脚本，这个之前分享的技巧可以结合，具体请移步通过<a href="https://liuzhengkaifa.github.io/2021/11/11/%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/#more">指令快速打开软件</a></p>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><h2 id="1、实现一"><a href="#1、实现一" class="headerlink" title="1、实现一"></a>1、实现一</h2><ol>
<li>先是编写确认，主要是<code>pause</code>指令，作用是会在dos窗口显示 请按任意键继续. . . 如果想反悔不执行了直接关闭dos窗口即可</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cls</span><br><span class="line">echo **********************************************</span><br><span class="line">echo.</span><br><span class="line">echo     一   键   布   署   发   布      </span><br><span class="line">echo.</span><br><span class="line">echo       安装请按任意键，退出直接关闭窗口</span><br><span class="line">echo.</span><br><span class="line">echo **********************************************</span><br><span class="line">echo.</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>依次执行<code>hexo clean</code> 和 <code>hexo g</code>指令，注意使用到了call指令，放在了hexo指令的前面，主要作用是执行完指令后任然返回到当前窗口，可以继续执行下面指令，不然一些指令本身带退出指令，就会造成下面指令无法执行。具体作用还请各位各自查询之~~~</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:step1</span><br><span class="line">cd /d d:\blog</span><br><span class="line">echo Please wait</span><br><span class="line">call hexo clean</span><br><span class="line">echo  clean finished...</span><br><span class="line"></span><br><span class="line">:step2</span><br><span class="line">call hexo g</span><br><span class="line">cls</span><br><span class="line">echo  generate finished...</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>询问是否部署到<code>GitHub</code>，这里主要是做了一个输入判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:step3</span><br><span class="line">set /p o=要部署到GitHub上吗? (YES NO):</span><br><span class="line">if /i &quot;%o%&quot;==&quot;yes&quot; goto yes</span><br><span class="line">if /i &quot;%o%&quot;==&quot;no&quot; goto no</span><br><span class="line">goto step3</span><br><span class="line">:yes</span><br><span class="line">call hexo d</span><br><span class="line">echo  deploy to GitHub finished...</span><br><span class="line">pause</span><br><span class="line">:no</span><br><span class="line">echo 你选择了不部署！</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>



<h2 id="3、实现三"><a href="#3、实现三" class="headerlink" title="3、实现三"></a>3、实现三</h2><p>根据我们之前的技巧，只需要将我们编写的脚本放到加入环境变量的文件夹中即可</p>
<p><img src="/2021/11/12/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89/image-20211113083252420.png" alt="image-20211113083252420"></p>
<p>然后快捷键<code>WIn+R</code>调出运行框，输入<code>hexocgd.bat</code>确定即可</p>
<p><img src="/2021/11/12/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89/image-20211113083548405.png" alt="image-20211113083548405"></p>
<h2 id="三、实现效果"><a href="#三、实现效果" class="headerlink" title="三、实现效果"></a>三、实现效果</h2><p><img src="/2021/11/12/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89/image-20211113084544330.png" alt="image-20211113084544330"></p>
<p>选择no,不部署</p>
<p><img src="/2021/11/12/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89/image-20211113092540550.png" alt="image-20211113092540550"></p>
<p>选择yes,部署</p>
<p><img src="/2021/11/12/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E5%8D%9A%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89/image-20211113092614842.png" alt="image-20211113092614842"></p>
<h1 id="四、脚本获取"><a href="#四、脚本获取" class="headerlink" title="四、脚本获取"></a>四、脚本获取</h1><p><a href="hexocgd.bat">hexocdg.bat脚本获取</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cls</span><br><span class="line">echo **********************************************</span><br><span class="line">echo.</span><br><span class="line">echo     一   键   布   署   发   布      </span><br><span class="line">echo.</span><br><span class="line">echo       安装请按任意键，退出直接关闭窗口</span><br><span class="line">echo.</span><br><span class="line">echo **********************************************</span><br><span class="line">echo.</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">:step1</span><br><span class="line">cd /d d:\blog</span><br><span class="line">echo Please wait</span><br><span class="line">call hexo clean</span><br><span class="line">echo  clean finished...</span><br><span class="line"></span><br><span class="line">:step2</span><br><span class="line">call hexo g</span><br><span class="line">echo  generate finished...</span><br><span class="line"></span><br><span class="line">:step3</span><br><span class="line">set /p o=要部署到GitHub上吗? (YES NO):</span><br><span class="line">if /i &quot;%o%&quot;==&quot;yes&quot; goto yes</span><br><span class="line">if /i &quot;%o%&quot;==&quot;no&quot; goto no</span><br><span class="line">goto step3</span><br><span class="line">:yes</span><br><span class="line">call hexo d</span><br><span class="line">echo  deploy to GitHub finished...</span><br><span class="line">pause</span><br><span class="line">:no</span><br><span class="line">echo 你选择了不部署！</span><br><span class="line">pause</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>bat</tag>
        <tag>hexo</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>更换电脑后转移hexo博客</title>
    <url>/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>刚了解hexo的时候就在考虑换电脑怎么转移博客，偶然机会看到了好朋友的博客，感觉很有帮助，然后也在这边做个记录，冲冲博客数量吧，哈哈哈哈~</p>
<p>毕竟只是有限，只能做个搬运工<a href="https://small-brilliant.github.io/2021/03/12/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%E6%88%91%E7%9A%84Bolg%E6%80%8E%E4%B9%88%E5%8A%9E/">好朋友的博客</a>；博客搞得相当好，有兴趣可以收藏哈哈哈哈~</p>
<span id="more"></span>

<h1 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h1><p>备份的大致思路就是</p>
<ol>
<li>在原有静态文件的GIt仓库新建一个分支，克隆到本地，然后本地在这个分支的管控下删除所有内容后提交，这样就相当于有了一个干净的分支</li>
<li>把博客的文件目录复制过来，然后再删除复制过来的版本信息，提交后push到远程分支</li>
<li>新电脑安装node.js，hexo后拉下该分支，使用该分支开发</li>
</ol>
<h1 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a>二、具体步骤</h1><h2 id="1、建立一个新的分支hexoSrc"><a href="#1、建立一个新的分支hexoSrc" class="headerlink" title="1、建立一个新的分支hexoSrc"></a>1、建立一个新的分支hexoSrc</h2><h4 id="（一）GitHub进入到hexo项目里"><a href="#（一）GitHub进入到hexo项目里" class="headerlink" title="（一）GitHub进入到hexo项目里"></a>（一）GitHub进入到hexo项目里</h4><p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211112221829134.png" alt="image-20211112221829134"></p>
<h4 id="（二）新建-分支"><a href="#（二）新建-分支" class="headerlink" title="（二）新建 分支"></a>（二）新建 分支</h4><p>点击master按钮，在弹出的框内输入新的分支名称，例如我的起名<strong>hexoSrc</strong></p>
<img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211112222236357.png" alt="image-20211112222236357" style="zoom: 67%;">

<h2 id="2、将原有的博客内容push到新分支上"><a href="#2、将原有的博客内容push到新分支上" class="headerlink" title="2、将原有的博客内容push到新分支上"></a>2、将原有的博客内容push到新分支上</h2><h4 id="（一）在任意目录下打开Git-Bash命令窗口，克隆新分支内容"><a href="#（一）在任意目录下打开Git-Bash命令窗口，克隆新分支内容" class="headerlink" title="（一）在任意目录下打开Git Bash命令窗口，克隆新分支内容"></a>（一）在任意目录下打开Git Bash命令窗口，克隆新分支内容</h4><p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211112222828591.png" alt="image-20211112222828591"></p>
<p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211112223130553.png" alt="image-20211112223130553"></p>
<h4 id="（二）清楚拉下来的分支内容提交，然后拷贝一份源文件提交"><a href="#（二）清楚拉下来的分支内容提交，然后拷贝一份源文件提交" class="headerlink" title="（二）清楚拉下来的分支内容提交，然后拷贝一份源文件提交"></a>（二）清楚拉下来的分支内容提交，然后拷贝一份源文件提交</h4><ol>
<li>第一次新拉下来分支是<code>master</code>，这是我们需要切换到我们创建的新分支上去</li>
</ol>
<p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211112223510668.png" alt="image-20211112223510668"></p>
<ol start="2">
<li>执行git <code>checkout -b</code> &lt;新分支名称&gt; &lt;远程分支&gt; 切换到新分支</li>
</ol>
<p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211112225520915.png" alt="image-20211112225520915"></p>
<ol start="3">
<li>删除除去.git目录外所有信息，并提交</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;删除该分支内容，准备放源文件&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>上传源文件。将我们之前写博客的文件夹里面的所有文件复制过来，<strong>除了</strong><code>.deploy_git</code>。<strong>如果你有自定义的主题的话</strong>，一定要删除主题文件中的<code>.git</code>文件夹，因为<code>git</code>不能嵌套上传。然后在这个文件夹打开<code>git bash</code>。输入下面命令，就上传了。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m &quot;上传博客源文件&quot;</span><br><span class="line">git push </span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211112230449539.png" alt="image-20211112230449539"></p>
<h4 id="（三）github将新建的分支hexoSrc设置为默认分支"><a href="#（三）github将新建的分支hexoSrc设置为默认分支" class="headerlink" title="（三）github将新建的分支hexoSrc设置为默认分支"></a>（三）github将新建的分支hexoSrc设置为默认分支</h4><p>依次点击 settings&gt;&gt;Branches&gt;&gt;switch</p>
<p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211115013154223.png" alt="image-20211115013154223"></p>
<p>在弹出的框内选择新建的分支hexoSrc,点击update</p>
<p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211115013227999.png" alt="image-20211115013227999"></p>
<h4 id="（四）将博客源码纳入git版本控制"><a href="#（四）将博客源码纳入git版本控制" class="headerlink" title="（四）将博客源码纳入git版本控制"></a>（四）将博客源码纳入git版本控制</h4><p>我们可以在一个空文件夹执行克隆操作，拉下来一份之前提交下来的源码，将文件夹下的.git拷贝到我们现在博客的根目录下即可</p>
<p>因为博客静态文件在配置里设置的提交分支master,所以我们本地保持分支状态和默认分支一样为hexoSrc即可</p>
<p><img src="/2021/11/12/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E8%BD%AC%E7%A7%BBhexo%E5%8D%9A%E5%AE%A2/image-20211115014102204.png" alt="image-20211115014102204"></p>
<p>我们在执行完hexo clean 、hexo g、hexo d后即可通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;提交博客源文件&quot;</span><br><span class="line">git push origin hexoSrc</span><br></pre></td></tr></table></figure>

<p>来完成源码的上传</p>
<h2 id="3、新电脑环境使用新分支继续博客编写"><a href="#3、新电脑环境使用新分支继续博客编写" class="headerlink" title="3、新电脑环境使用新分支继续博客编写"></a>3、新电脑环境使用新分支继续博客编写</h2><ol>
<li>安装<code>git</code>和<code>node.js</code></li>
<li>设置<code>git</code>全局邮箱和用户名</li>
<li>新电脑生成公钥，将公钥配置到Github上</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourgithubname&quot;</span><br><span class="line">git config --global user.email &quot;yourgithubemail&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装<code>hexo</code>但是不需要初始化。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>然后进入克隆到的文件夹。安装环境</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone XXX.git</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>验证</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>然后就可以开始写你的新博客了。每次写完都要把源文件上传一下。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m &quot;xxxx&quot;</span><br><span class="line">git push </span><br></pre></td></tr></table></figure>

<ol start="7">
<li>如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>通过指令快速打开软件</title>
    <url>/2021/11/11/%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>每次桌面打开一堆页面，再想要去打开一个新的软件，如何不用返回屏幕也不用触碰鼠标快速秒开软件呢，</p>
<span id="more"></span>

<h1 id="一、建立文件夹"><a href="#一、建立文件夹" class="headerlink" title="一、建立文件夹"></a>一、建立文件夹</h1><ol>
<li><p>首先在任意位置建个文件夹</p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/image-20211111175928832.png" alt="image-20211111175928832"></p>
</li>
</ol>
<h1 id="二、将文件目录配到环境变量中"><a href="#二、将文件目录配到环境变量中" class="headerlink" title="二、将文件目录配到环境变量中"></a>二、将文件目录配到环境变量中</h1><ol>
<li>点击桌面此电脑 右击 选择属性</li>
<li>点击高级系统设置，弹出页面点击环境变量</li>
</ol>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/image-20211111180102457.png" alt="image-20211111180102457"></p>
<ol start="3">
<li>选中Path然后点解编辑</li>
</ol>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/image-20211111180233166.png" alt="image-20211111180233166"></p>
<ol start="4">
<li>点击新建，将新建的文件夹路径配置进去，然后点击确定完成操作</li>
</ol>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/image-20211111180406382.png" alt="image-20211111180406382"></p>
<h1 id="三、存放快捷方式"><a href="#三、存放快捷方式" class="headerlink" title="三、存放快捷方式"></a>三、存放快捷方式</h1><p><strong>将一些常用的软件快捷方式按照自己习惯命名放到新建的文件夹中</strong></p>
<img src="/2021/11/11/%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/image-20211111180543035.png" alt="image-20211111180543035" style="zoom:67%;">

<p><strong>这样在任意界面都可以通过快捷键Win+R调出左下角运行输入框</strong></p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6/image-20211111180706062.png" alt="image-20211111180706062"></p>
<p><strong>输入自己命名的快捷方式（直接输过的敲一个字母就会带出来）回车边立即打开相应软件</strong></p>
<p>是不是相当nice~~~~</p>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>通过共享实现电脑间文件传递</title>
    <url>/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p><strong>背景：在办公时，你要发给小明一个很大的文件，u盘存放不下，且传输速度慢，怎么解决</strong></p>
<p><strong>一、在你一个本地空间新建一个文件夹FileReceive</strong></p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/a8b1afbf5bbc430bb3b4132767d35975.png" alt="img"></p>
<span id="more"></span> 

<p><strong>二、右键属性，点击共享</strong></p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/be1e6ae5c2c84f1bb3c19ddb4f1d4e5f.png" alt="img"></p>
<p> <strong>三、选择共享账号为everyone,这之后会有一个窗口提示共享已完成，点击右下角的“完成”按钮</strong></p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/928ca4e2ef13437e9c5ff9df90a4354e.png" alt="img"></p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/e36c11e7ffcb41c0bad8c815f78ca397.png" alt="img"></p>
<p> <strong>四、虽然现在共享给了Everyone，但是组和用户那里却没有Everyone，需要另行添加。点击箭头所指处的“编辑”。</strong></p>
<p> <img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/1b9e8951ac1c4a6bbf8423b51bf8e5a9.png" alt="img"></p>
<p> <strong>五、在“FileReceive的权限”窗口中点击箭头所指处的“添加”。</strong></p>
<p> <img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/db762c242f92479fb1d54b29811ec9d3.png" alt="img"></p>
<p> <strong>六、在“选择组和用户”窗口中点击“高级”。</strong> </p>
<p> <img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/6eb3ea6e500e4c34a5819aa5b3ee1e86.png" alt="img"></p>
<p>  <strong>七、点击“立即查找”，在搜索结果中找到Everyone，双击添加，然后点击确定。</strong></p>
<p> <img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/404e1f88728941e58813c17682d28bc6.png" alt="img"></p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/7ca724ffe1054cddaa33d96830dc79ca.png" alt="img"></p>
<p>  <strong>八、勾选Everyone的所有权限，如下图所示，然后点击“应用”，“确定”。</strong> </p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/d1e03223471b4548ac96e8e7929576e6.png" alt="img"></p>
<p>  <strong>九、使用win+r快捷键调出运行窗口，输入\+IP地址，连接至电脑B的共享。</strong> </p>
<p><img src="/2021/11/11/%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%97%B4%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92/1bbc15b8aa784bfe8fb8a3faad79768f.png" alt="img"></p>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>shell编写心得</title>
    <url>/2021/11/11/shell%E7%BC%96%E5%86%99%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>使用shell脚本在linux服务器上可以帮助我们处理很多工作，想要追求效率，会编写shell脚本是非常有必要的</p>
<span id="more"></span>

<h1 id="一、快速开始"><a href="#一、快速开始" class="headerlink" title="一、快速开始"></a>一、快速开始</h1><ol>
<li>创建一个新shell文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi demo.sh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加脚本头文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#bin/sh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>授权和执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 demo.sh -授权</span><br><span class="line">./demo.sh    -执行</span><br></pre></td></tr></table></figure>

<p>示例脚本demo.sh：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#bin/sh</span><br><span class="line">echo hello world</span><br></pre></td></tr></table></figure>

<h1 id="二、常用语法"><a href="#二、常用语法" class="headerlink" title="二、常用语法"></a>二、常用语法</h1><h3 id="1、变量的赋值和使用"><a href="#1、变量的赋值和使用" class="headerlink" title="1、变量的赋值和使用"></a>1、变量的赋值和使用</h3><p><code>$1</code> 代表输入执行脚本传递来的第一个参数，变量赋值时不需要带$符号，在输出使用时需要带</p>
<p><strong>变量两边不能加空格</strong></p>
<p>示例：demo1.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#bin/sh</span><br><span class="line">name=xiaoming</span><br><span class="line">echo $1</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./demo1.sh 这是传的第一个参数</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/2021/11/11/shell%E7%BC%96%E5%86%99%E5%BF%83%E5%BE%97/image-20211115101925191.png" alt="image-20211115101925191"></p>
<h3 id="2、if-else-和-Case-判断"><a href="#2、if-else-和-Case-判断" class="headerlink" title="2、if else 和 Case 判断"></a>2、if else 和 Case 判断</h3><h4 id="（一）if-else"><a href="#（一）if-else" class="headerlink" title="（一）if else"></a>（一）if else</h4><p><strong>注意 if 和 [ 之间要有空格，= 号两边也要有空格</strong></p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ &quot;$1&quot; = &quot;&quot; ] ; then</span><br><span class="line">    echo 未传参数</span><br><span class="line">    exit</span><br><span class="line">else</span><br><span class="line">    echo $1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/11/shell%E7%BC%96%E5%86%99%E5%BF%83%E5%BE%97/image-20211115102535466.png" alt="image-20211115102535466"></p>
<h4 id="（二）Case"><a href="#（二）Case" class="headerlink" title="（二）Case"></a>（二）Case</h4><p>类似<code>java</code>语法中的<code>switch-case</code>选择</p>
<p>示例代码：如果输入的参数有38的话，将执行ips+=(‘172.XXX.XX.38’)，有40的话将执行 ips+=(‘172.XXX.XX.40’)，</p>
<p>都不符合条件将执行最后的提示echo “请输入正确服务器ip编号”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ips=() </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span> </span><br><span class="line">        <span class="string">&quot;38&quot;</span>)</span><br><span class="line">		ips+=(<span class="string">&#x27;172.XXX.XX.38&#x27;</span>)</span><br><span class="line">		;;</span><br><span class="line">	<span class="string">&quot;40&quot;</span>)</span><br><span class="line">        ips+=(<span class="string">&#x27;172.XXX.XX.40&#x27;</span>)</span><br><span class="line">         ;;</span><br><span class="line">	*)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;请输入正确服务器ip编号&quot;</span></span><br><span class="line">	;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h3 id="3、常用的一些文件表达式"><a href="#3、常用的一些文件表达式" class="headerlink" title="3、常用的一些文件表达式"></a>3、常用的一些文件表达式</h3><h4 id="（一）文件表达式"><a href="#（一）文件表达式" class="headerlink" title="（一）文件表达式"></a>（一）文件表达式</h4><table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-e filename</td>
<td>如果 filename存在，则为真</td>
</tr>
<tr>
<td>-f filename</td>
<td>如果 filename为常规文件，则为真</td>
</tr>
<tr>
<td>-L filename</td>
<td>如果 filename为符号链接，则为真</td>
</tr>
<tr>
<td>-r filename</td>
<td>如果 filename可读，则为真</td>
</tr>
<tr>
<td>-w filename</td>
<td>如果 filename可写，则为真</td>
</tr>
<tr>
<td>-x filename</td>
<td>如果 filename可执行，则为真</td>
</tr>
<tr>
<td>-s filename</td>
<td>如果文件长度不为0，则为真</td>
</tr>
<tr>
<td>-h filename</td>
<td>如果文件是软链接，则为真</td>
</tr>
<tr>
<td>filename1 -nt filename2</td>
<td>如果 filename1比 filename2新，则为真</td>
</tr>
<tr>
<td>filename1 -ot filename2</td>
<td>如果 filename1比 filename2旧，则为真</td>
</tr>
</tbody></table>
<h4 id="（二）整数变量表达式"><a href="#（二）整数变量表达式" class="headerlink" title="（二）整数变量表达式"></a>（二）整数变量表达式</h4><table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>等于</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于</td>
</tr>
<tr>
<td>-gt</td>
<td>大于</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于</td>
</tr>
<tr>
<td>-lt</td>
<td>小于</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于</td>
</tr>
</tbody></table>
<h4 id="（三）字符串变量表达式"><a href="#（三）字符串变量表达式" class="headerlink" title="（三）字符串变量表达式"></a>（三）字符串变量表达式</h4><table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>If  [ $a = $b ]</td>
<td>如果string1等于string2，则为真；字符串允许使用赋值号做等号</td>
</tr>
<tr>
<td>if  [ $string1 !=  $string2 ]</td>
<td>如果string1不等于string2，则为真</td>
</tr>
<tr>
<td>if  [ -n $string  ]</td>
<td>如果string 非空(非0），返回0(true)</td>
</tr>
<tr>
<td>if  [ -z $string  ]</td>
<td>如果string 为空，则为真</td>
</tr>
<tr>
<td>if  [ $sting ]</td>
<td>如果string 非空，返回0 (和-n类似)</td>
</tr>
</tbody></table>
<h4 id="（四）逻辑表达式"><a href="#（四）逻辑表达式" class="headerlink" title="（四）逻辑表达式"></a>（四）逻辑表达式</h4><table>
<thead>
<tr>
<th>说明</th>
<th>表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑非！</td>
<td>if [ ! 表达式 ] 示例： if [ ! -d $num ]</td>
<td>如果不存在目录$num</td>
</tr>
<tr>
<td>逻辑与 –a</td>
<td>if [ 表达式1  –a  表达式2 ]</td>
<td>条件表达式的并列，并的意思</td>
</tr>
<tr>
<td>逻辑或 -o</td>
<td>if [ 表达式1  –o 表达式2 ]</td>
<td>条件表达式的或</td>
</tr>
</tbody></table>
<h3 id="4、字符串处理"><a href="#4、字符串处理" class="headerlink" title="4、字符串处理"></a>4、字符串处理</h3><h4 id="（一）字符串截取表达式"><a href="#（一）字符串截取表达式" class="headerlink" title="（一）字符串截取表达式"></a>（一）字符串截取表达式</h4><p>示例：${1:0:10} </p>
<p>大括号中的第一位是变量，1代表输入的第一个参数值，中间参数代表变量字符串开始位置，最后一个参数代表截取长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#bin/sh</span><br><span class="line">str=&quot;12345678&quot;</span><br><span class="line">echo &quot;从第三位值3，对应下标为2（结果包含该位），开始截取，长度为3&quot;</span><br><span class="line">echo $&#123;str:2:3&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/11/shell%E7%BC%96%E5%86%99%E5%BF%83%E5%BE%97/image-20211115105757300.png" alt="image-20211115105757300"></p>
<h4 id="（二）字符串值替换表达式"><a href="#（二）字符串值替换表达式" class="headerlink" title="（二）字符串值替换表达式"></a>（二）字符串值替换表达式</h4><p>${str/aaa/bbb} </p>
<p>str：变量字符串，和$str内容一样，aaa：要替换上去的字符串，bbb：变量str上含有的字符串</p>
<p>示例：将输入的内容Patch 替换为liuzheng</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#bin/sh</span><br><span class="line">echo &quot;测试====$&#123;1/Patch/liuzheng&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/11/shell%E7%BC%96%E5%86%99%E5%BF%83%E5%BE%97/image-20211115110251950.png" alt="image-20211115110251950"></p>
<h3 id="5、数组和map集合"><a href="#5、数组和map集合" class="headerlink" title="5、数组和map集合"></a>5、数组和map集合</h3><h4 id="（一）数组"><a href="#（一）数组" class="headerlink" title="（一）数组"></a>（一）数组</h4><ol>
<li>数组定义</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.定义一个空数组</span><br><span class="line">arr=()</span><br><span class="line">#2.定义数组并赋初始值</span><br><span class="line">arr=(&#x27;38&#x27; &#x27;40&#x27;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取数组长度</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length=$&#123;#arr[*]&#125;</span><br><span class="line">echo $length</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数组添加新元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr+=(&#x27;55&#x27;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>读取数组值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;arr[index]&#125; #index 为元素在下标中的位置，从0开始</span><br><span class="line">$&#123;arr[*]&#125; #获取数组中所有元素，示例输出：数组的元素为: A B C D</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>数组删除某一元素</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset arr[index] #删除数组下标index元素</span><br></pre></td></tr></table></figure>

<h4 id="（二）map集合"><a href="#（二）map集合" class="headerlink" title="（二）map集合"></a>（二）map集合</h4><p>在shell脚本中也可以使用map，这对我们有键值对需求的存储提供了方便</p>
<ol>
<li>map声明</li>
</ol>
<p>在使用map时，需要先声明，否则结果可能与预期不同，array可以不声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare -A map</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>map初始化</li>
</ol>
<p>与array类似，可以使用括号直接初始化，也可以通过添加的方式来初始化数据</p>
<p>与array不同的是，括号直接初始化时使用的为一个键值对，添加元素时，下标可以不是整数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map=([&quot;aa&quot;]=&quot;11&quot; [&quot;bb&quot;]=&quot;22&quot;)</span><br><span class="line">map[&quot;name&quot;]=&quot;val&quot;</span><br><span class="line">map[&quot;apple&quot;]=&quot;pen&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>输出所有key</li>
</ol>
<p>若未使用declare声明map，则此处将输出0，与预期输出不符，此处输出语句格式比arry多了一个！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;!map[@]&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>输出所有value</li>
</ol>
<p>与array输出格式相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;map[@]&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>输出map长度</li>
</ol>
<p>与array输出格式相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $&#123;#map[@]&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>遍历所有key</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for key in $&#123;!map[@]&#125;;do</span><br><span class="line">    echo $key</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>遍历所有value</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for val in $&#123;map[@]&#125;;do</span><br><span class="line">    echo $val</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>遍历，根据key，找到value</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for key in $&#123;!map[*]&#125;;do</span><br><span class="line">    echo $&#123;map[$key]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="6、循环遍历"><a href="#6、循环遍历" class="headerlink" title="6、循环遍历"></a>6、循环遍历</h3><p>此处是循环遍历了一个数组arr:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ip in $&#123;arr[*]&#125;; do</span><br><span class="line">   echo $ip</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h1 id="三、常用指令"><a href="#三、常用指令" class="headerlink" title="三、常用指令"></a>三、常用指令</h1><h3 id="1、echo"><a href="#1、echo" class="headerlink" title="1、echo"></a>1、echo</h3><p>输出命令，常用来做一些提示信息</p>
<p>搭配一些字字体颜色或者字背景颜色区分性更强，可以参考：<a href="https://www.cnblogs.com/ElegantSmile/p/11144879.html">Shell~echo -e 颜色输出</a></p>
<h3 id="2、zip、unzip"><a href="#2、zip、unzip" class="headerlink" title="2、zip、unzip"></a>2、zip、unzip</h3><p>zip -qr [目标文件名] [源文件名]</p>
<ul>
<li>-q 不显示指令执行过程。</li>
<li>-r 递归处理，将指定目录下的所有文件和子目录一并处理。</li>
</ul>
<p>unzip xxx.zip</p>
<p>将xxx.zip解压到当前目录</p>
<h3 id="3、rsync"><a href="#3、rsync" class="headerlink" title="3、rsync"></a>3、rsync</h3><p>rsync 是一个常用的 Linux 应用程序，用于文件同步</p>
<p>基本用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -r source destination</span><br></pre></td></tr></table></figure>

<p>上面命令中，<code>-r</code>表示递归，即包含子目录。注意，<code>-r</code>是必须的，否则 rsync 运行不会成功。<code>source</code>目录表示源目录，<code>destination</code>表示目标目录。</p>
<p>搭配sshpass可以实现服务器之间的目录文件同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sshpass -p &quot;IP地址&quot; rsync -rvc --delete 本机目录一 本机目录二 用户名@$ip:远程服务目录</span><br><span class="line"></span><br><span class="line">#项目中使用的</span><br><span class="line">/usr/local/bin/sshpass -p &quot;$&#123;ipmaps[$key]&#125;&quot; rsync -rvc --delete $appdir/citsonline $appdir/citsb2b weblogic@$ip:$appdir</span><br></pre></td></tr></table></figure>

<p><a href="http://www.ruanyifeng.com/blog/2020/08/rsync.html">rsync 详细用法教程</a></p>
<h3 id="4、sshpass"><a href="#4、sshpass" class="headerlink" title="4、sshpass"></a>4、sshpass</h3><p>sshpass需要安装，可以通过显性配置账密，实现服务器之间无需手动输入密码进行交互，除了上面的rsync通过sshpass实现免密同步目录文件信息操作</p>
<p>还可以实现服务器间脚本远程执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sshpass -p &quot;密码&quot; ssh 有户名@&quot;IP地址&quot; &quot;/home/newStop.sh&quot; #远程脚本</span><br></pre></td></tr></table></figure>

<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>目前我也是一边学习使用一边记录，这个文章才是冰山一角，后面在使用到过程中继续不断补充完善~~~</p>
<p>在后续使用中可以参考<a href="https://wangdoc.com/bash/script.html">Bash学习</a></p>
]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用操作</title>
    <url>/2021/11/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>git作为一款分布式版本控制工具，目前已逐渐成为开发团队首选的协作工具，相比SVN其优势不言而喻</p>
<ol>
<li>均有分布式思想，每个版本库都拥有完整的版本历史记录</li>
<li>分支功能很强大，不像svn分了分支之后，合并代码要人工去比对，虽然有强大的文件比较工具<a href="https://www.beyondcomparepro.com/">BeyondCompare</a> 加持，但仍然是人工操作，分支比较多，同时操作相同文件时冲突解决等不可避免出现问题。git通过merge能够自动合并分支代码，分支开发很大提高了协作效率。分支操作也会写在下面</li>
</ol>
<span id="more"></span>

<h2 id="二、基础理解"><a href="#二、基础理解" class="headerlink" title="二、基础理解"></a>二、基础理解</h2><p><img src="/2021/11/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/wps257.jpg" alt="img"></p>
<h3 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1.相关概念"></a>1.相关概念</h3><ol>
<li>工作区（workspace）:我们正常的文件夹</li>
<li>本地仓库（Repository）:隐藏的.git文件夹</li>
<li><a href="https://www.cnblogs.com/cposture/p/4178003.html">暂存区</a>：简而言之即使文件索引，建立了文件和.git/objects目录下的对象实体之间的映射关系</li>
</ol>
<p><img src="/2021/11/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/221333249999513.png" alt="img"></p>
<ol start="4">
<li>远程仓库（Remote）:一般是存放在服务器上，本地通过 git push将代码推送到远程</li>
</ol>
<h2 id="三、分支操作"><a href="#三、分支操作" class="headerlink" title="三、分支操作"></a>三、分支操作</h2><h3 id="一、分支管理（git协作管理规范）"><a href="#一、分支管理（git协作管理规范）" class="headerlink" title="一、分支管理（git协作管理规范）"></a>一、分支管理（git协作管理规范）</h3><p>实际开发的时候，一人一条分支。除此之外还要有一条devlop开发分支，一条test分支,一条release预发布分支</p>
<ol>
<li><strong>develop</strong>开发分支，开发共用的分支，开发人员每天都需要拉取/提交最新代码的分支；</li>
<li><strong>test</strong>测试分支，发人员开发完并自测通过后，发布到测试环境的分支；</li>
<li><strong>release</strong>预发布分支，测试环境测试通过后，将测试分支的代码发布到预发环境的分支（这个得看公司支不支持预发环境，没有的话就可以不采用这条分支）</li>
<li><strong>master</strong>生产分支，预发环境测试通过后，运营/测试会将此分支代码发布到线上环境；</li>
</ol>
<p>开发流程：</p>
<ul>
<li>开发人员每天都需要拉取/提交最新的代码到 <strong>「develop 分支」</strong>；</li>
<li>开发人员开发完毕，开始 <strong>「集成测试」</strong>，测试无误后提交到 <strong>「test 分支」</strong>并发布到测试环境，交由测试人员测试；</li>
<li>测试环境通过后，发布到 <strong>「release 分支」</strong> 上，进行预发环境测试；</li>
<li>预发环境通过后，发布到 <strong>「master 分支」</strong>上并打上标签（tag）；</li>
<li>如果线上分支出了 bug ，这时候相关开发者应该基于预发布分支（<strong>「没有预发环境，就使用 master 分支」</strong>），新建一个 <strong>「bug 分支」</strong>用来临时解决 bug ，处理完后申请合并到 预发布 分支。这样做的好处就是：不会影响正在开发中的功能。</li>
</ul>
<p><strong>「预发布环境的作用：」</strong> 预发布环境是正式发布前最后一次测试。因为在少数情况下即使预发布通过了，都不能保证正式生产环境可以100%不出问题；预发布环境的配置，数据库等都是跟线上一样；有些公司的预发布环境数据库是连接线上环境，有些公司预发布环境是单独的数据库；如果不设预发布环境，如果开发合并代码有问题，会直接将问题发布到线上，增加维护的成本。</p>
<p> 对分支的操作是轻量级的</p>
<h3 id="二、分支图解"><a href="#二、分支图解" class="headerlink" title="二、分支图解"></a>二、分支图解</h3><p>如下图，当前有两个分支，ACE属于mster分支，而BDF属于dev分支，他们的head指针分别指向E和F</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A----C----E(master)</span><br><span class="line">\</span><br><span class="line"> B---D----F(dev)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>对上述做如下操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git checkout mster <span class="comment">//选择 or 切换 到mster分支</span></span><br><span class="line">git merge dev      <span class="comment">//将dev分支合并到当前分支（mster）中</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>分支合并完成后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A----C----E----G(mster)</span><br><span class="line">\              /</span><br><span class="line">  B-----D----F</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>现在ABCDEFG属于mster分支，G是一次E和F合并后的结果，可能会出现冲突。而ABDF依然属于dev分支，可以继续再dev的分支上进行开发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A----C----E----G(mster)</span><br><span class="line">\              /</span><br><span class="line">  B-----D----F ------I(dev)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="三、分支的基本操作"><a href="#三、分支的基本操作" class="headerlink" title="三、分支的基本操作"></a>三、分支的基本操作</h3><ol>
<li>git branch //查看本地的所有分支</li>
<li>git branch -r //查看远程所有分支</li>
<li>git branch -a //查看本地和远程的所有分支</li>
<li>git branch &lt;branchname&gt;   //新建分支</li>
<li>git branch -d &lt;branchname&gt; //删除本地分支</li>
<li>git branch -d -r &lt;branchname&gt; //删除远程分支，删除后还需推送到服务器</li>
<li>git branch origin:&lt;branchname&gt; //删除后推送至服务器</li>
<li>git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; //重命名本地分支</li>
<li>git checkout &lt;branchname&gt;//切换分支</li>
<li>git checkout -b &lt;branchname&gt;//创建并切换分行之</li>
<li>git checkout -b &lt;branchname&gt; origin:&lt;remoteBranchName&gt;//创建分支并切换，分支跟远程分支保持一致</li>
</ol>
<h2 id="四、常用操作"><a href="#四、常用操作" class="headerlink" title="四、常用操作"></a>四、常用操作</h2><h3 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.git init --初始化git仓库</span><br><span class="line">2.git clone url [dir] --克隆远程仓库到本地 [dir]代表克隆存放到的本地文件夹</span><br><span class="line">3.git config –global user.name [username] --全局提交的用户名</span><br><span class="line">4.git config –global user.email[email] --全局提交的额邮箱</span><br><span class="line">5.git add .  --增加当前文件夹所有文件到暂存区</span><br><span class="line">6.git commit -m &quot;一次新的提交&quot;  --将暂存区内容提交到本地仓库</span><br><span class="line">7.git push origin hexoSrc  --push到远程仓库</span><br></pre></td></tr></table></figure>

<h3 id="2、git-remote"><a href="#2、git-remote" class="headerlink" title="2、git remote"></a>2、git remote</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote --查看已经配置的远程仓库服务器</span><br><span class="line">git remote add [shortname] [url] --为本地仓库添加远程仓库</span><br></pre></td></tr></table></figure>

<h3 id="3、git-merge"><a href="#3、git-merge" class="headerlink" title="3、git merge"></a>3、git merge</h3><p>合并分支，例如：将test分支合到master分支，并推动到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.git checkout master   --切换到master分支</span><br><span class="line">2.git merge test  --将test分支河道master分支</span><br><span class="line">3.git pust --推送到远程仓库</span><br></pre></td></tr></table></figure>

<h3 id="4、git-stash"><a href="#4、git-stash" class="headerlink" title="4、git stash"></a>4、git stash</h3><p>git stash可以将当前分支未提交的修改推到Git的栈中，然后切到其他分支进行操作，返回当前分支后再释放就能完整恢复离开前状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.git stash --将当前分支的修改提交到git栈中，stash是本地的，不会通过git push命令传到git 服务器上</span><br><span class="line">2.git stash save &quot;test-cmd-stash&quot; --实际应用中使用git stash save 取代git stash 命令，添加一个message信息</span><br><span class="line">3.git stash pop  --恢复之前缓存的工作目录</span><br></pre></td></tr></table></figure>



<h3 id="5、git-fetch-用法"><a href="#5、git-fetch-用法" class="headerlink" title="5、git fetch 用法"></a>5、git fetch 用法</h3><p>git fetch 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地</span><br></pre></td></tr></table></figure>

<p>如果只想取回特定分支的更新，可以指定分支名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格</span><br></pre></td></tr></table></figure>

<p>最常见的命令如取回<code>origin</code> 主机的<code>master</code> 分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure>

<p>取回更新后，会返回一个<code>FETCH_HEAD</code> ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log -p FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p>可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码（19行红色[删除]和绿色[新增]部分）。</p>
<p>我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。 </p>
<p>2、git pull 用法</p>
<p>前面提到，<code>git pull</code> 的过程可以理解为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin master //从远程主机的master分支拉取最新内容</span><br><span class="line"></span><br><span class="line">git merge FETCH_HEAD //将拉取下来的最新内容合并到当前所在的分支中</span><br></pre></td></tr></table></figure>

<p>即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure>



<h3 id="6、git-pull-–rebase-和git-pull的区别"><a href="#6、git-pull-–rebase-和git-pull的区别" class="headerlink" title="6、git pull –rebase 和git pull的区别"></a>6、git pull –rebase 和git pull的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull = git fecth + git merge FETCH_HEAD</span><br><span class="line"> git pull -- rebase = git fetch + git rebase FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p>二者的区别是，在fetch之后的操作不同，<strong>merge与rebase的不同</strong></p>
<p>假设当前mster的提交操作如下：</p>
<p>cid1—-&gt; cid2—-&gt; cid3—-&gt; cid4—-&gt; cid5        –当前master的提交记录</p>
<p>当开发同事在cid2点，开发进度是cid20(或者突然撇出一个分支，假设是tmp分支），此时要把cid20提交到master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> cid20---&gt;cid21  tmp分支</span><br><span class="line">        /</span><br><span class="line">cid1----&gt; cid2----&gt; cid3----&gt; cid4----&gt; cid5  当前master的提交记录</span><br></pre></td></tr></table></figure>



<p>在master执行  git merge tmp , 然后会得到如下结果</p>
<p>​     <img src="/2021/11/11/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/20210902170456933.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>那么来看看git rebase，在mster执行 git rebase tmp 操作之后的分支如下</p>
<p>cid1—-&gt; cid2—-&gt; cid20—-&gt; cid21—-&gt; cid3‘—-&gt; cid4’—-&gt; cid5‘  当前master的提交记录</p>
<p> 二者对比可知，<strong>rebase没有产生新的节点，使用rebase的git演进路线(提交树)是一直向前的，这样在版本回退时也很容易</strong>，用merge的git路线是跳跃的，如果版本回退你也找不到自己想要的版本，如果在merge时出现了冲突那就麻烦了，当前merge就不能继续进行下去，需要手动修改冲突内容后，add，commit, push. 而rebase 操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后, 再执行 git rebase –continue 继续操作，再push.</p>
]]></content>
      <categories>
        <category>开发辅助</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令使用记录</title>
    <url>/2021/11/11/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="⽂件查看和处理"><a href="#⽂件查看和处理" class="headerlink" title="⽂件查看和处理"></a>⽂件查看和处理</h1><span id="more"></span>

<table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cat file1</td>
<td>查看⽂件内容</td>
</tr>
<tr>
<td>cat -n file1</td>
<td>查看内容并标示⾏数</td>
</tr>
<tr>
<td>tac file1</td>
<td>从最后⼀⾏开始反看⽂件内容</td>
</tr>
<tr>
<td>more file1</td>
<td>more file1</td>
</tr>
<tr>
<td>less file1</td>
<td>类似more命令，但允许反向操作</td>
</tr>
<tr>
<td>head -2 file1</td>
<td>查看⽂件前两⾏</td>
</tr>
<tr>
<td>tail -2 file1</td>
<td>查看⽂件后两⾏</td>
</tr>
<tr>
<td>tail -f /log/msg</td>
<td>实时查看添加到⽂件中的内容</td>
</tr>
<tr>
<td>grep codesheep hello.txt</td>
<td>在⽂件hello.txt中查找关键词codesheep</td>
</tr>
<tr>
<td>grep ^sheep hello.txt</td>
<td>在⽂件hello.txt中查找以sheep开头的内容</td>
</tr>
<tr>
<td>grep [0-9] hello.txt</td>
<td>选择hello.txt⽂件中所有包含数字的⾏</td>
</tr>
<tr>
<td>sed ‘s/s1/s2/g’ hello.txt</td>
<td>将hello.txt⽂件中的s1替换成s2</td>
</tr>
<tr>
<td>sed ‘/^$/d’ hello.txt</td>
<td>从hello.txt⽂件中删除所有空⽩⾏</td>
</tr>
<tr>
<td>sed ‘/ *#/d; /^$/d’ hello.txt</td>
<td>从hello.txt⽂件中删除所有注释和空⽩⾏</td>
</tr>
<tr>
<td>sed -e ‘1d’ hello.txt</td>
<td>从⽂件hello.txt 中排除第⼀⾏</td>
</tr>
<tr>
<td>sed -n ‘/s1/p’ hello.txt</td>
<td>查看只包含关键词”s1”的⾏</td>
</tr>
<tr>
<td>sed -e ‘s/ *$//‘ hello.txt</td>
<td>删除每⼀⾏最后的空⽩字符</td>
</tr>
<tr>
<td>sed -e ‘s/s1//g’ hello.txt</td>
<td>从⽂档中只删除词汇s1并保留剩余全部</td>
</tr>
<tr>
<td>sed -n ‘1,5p;5q’ hello.txt</td>
<td>查看从第⼀⾏到第5⾏内容</td>
</tr>
<tr>
<td>sed -n ‘5p;5q’ hello.txt</td>
<td>查看第5⾏</td>
</tr>
<tr>
<td>paste file1 file2</td>
<td>合并两个⽂件或两栏的内容</td>
</tr>
<tr>
<td>paste -d ‘+’ file1 file2</td>
<td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td>
</tr>
<tr>
<td>sort file1 file2</td>
<td>排序两个⽂件的内容</td>
</tr>
<tr>
<td>comm -1 file1 file2</td>
<td>⽐较两个⽂件的内容(去除’file1’所含内容)</td>
</tr>
<tr>
<td>comm -2 file1 file2</td>
<td>⽐较两个⽂件的内容(去除’file2’所含内容</td>
</tr>
<tr>
<td>comm -3 file1 file2</td>
<td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td>
</tr>
</tbody></table>
<h1 id="⽂件和⽬录操作"><a href="#⽂件和⽬录操作" class="headerlink" title="⽂件和⽬录操作"></a>⽂件和⽬录操作</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cd &lt;⽬录名&gt;</td>
<td>进⼊某个⽬录</td>
</tr>
<tr>
<td>cd ..</td>
<td>回上级⽬录</td>
</tr>
<tr>
<td>cd ../..</td>
<td>回上两级⽬录</td>
</tr>
<tr>
<td>cd</td>
<td>进个⼈主⽬录</td>
</tr>
<tr>
<td>cd -</td>
<td>回上⼀步所在⽬录</td>
</tr>
<tr>
<td>pwd</td>
<td>显示当前路径</td>
</tr>
<tr>
<td>ls</td>
<td>查看⽂件⽬录列表</td>
</tr>
<tr>
<td>ls -F</td>
<td>查看⽬录中内容（显示是⽂件还是⽬录）</td>
</tr>
<tr>
<td>ls -l</td>
<td>查看⽂件和⽬录的详情列表</td>
</tr>
<tr>
<td>ls -a</td>
<td>查看隐藏⽂件</td>
</tr>
<tr>
<td>ls -lh</td>
<td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td>
</tr>
<tr>
<td>ls -lSr</td>
<td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td>
</tr>
<tr>
<td>tree</td>
<td>查看⽂件和⽬录的树形结构</td>
</tr>
<tr>
<td>mkdir &lt;⽬录名&gt;</td>
<td>创建⽬录</td>
</tr>
<tr>
<td>mkdir dir1 dir2</td>
<td>同时创建两个⽬录</td>
</tr>
<tr>
<td>mkdir -p /tmp/dir1/dir2</td>
<td>创建⽬录树</td>
</tr>
<tr>
<td>rm -f file1</td>
<td>删除’file1’⽂件</td>
</tr>
<tr>
<td>rmdir dir1</td>
<td>删除’dir1’⽬录</td>
</tr>
<tr>
<td>rm -rf dir1</td>
<td>删除’dir1’⽬录和其内容</td>
</tr>
<tr>
<td>rm -rf dir1 dir2</td>
<td>同时删除两个⽬录及其内容</td>
</tr>
<tr>
<td>mv old_dir new_dir</td>
<td>重命名/移动⽬录</td>
</tr>
<tr>
<td>cp file1 file2</td>
<td>复制⽂件</td>
</tr>
<tr>
<td>cp dir/* .</td>
<td>复制某⽬录下的所有⽂件⾄当前⽬录</td>
</tr>
<tr>
<td>cp -a dir1 dir2</td>
<td>复制⽬录</td>
</tr>
<tr>
<td>cp -a /tmp/dir1 .</td>
<td>复制⼀个⽬录⾄当前⽬录</td>
</tr>
<tr>
<td>ln -s file1 link1</td>
<td>创建指向⽂件/⽬录的软链接</td>
</tr>
<tr>
<td>ln file1 lnk1</td>
<td>创建指向⽂件/⽬录的物理链接</td>
</tr>
<tr>
<td>find / -name file1</td>
<td>从跟⽬录开始搜索⽂件/⽬录</td>
</tr>
<tr>
<td>find / -user user1</td>
<td>搜索⽤户user1的⽂件/⽬录</td>
</tr>
<tr>
<td>find /dir -name *.bin</td>
<td>在⽬录/dir中搜带有.bin后缀的⽂件</td>
</tr>
<tr>
<td>locate &lt;关键词&gt;</td>
<td>快速定位⽂件</td>
</tr>
<tr>
<td>locate *.mp4</td>
<td>寻找.mp4结尾的⽂件</td>
</tr>
<tr>
<td>whereis &lt;关键词&gt;</td>
<td>显示某⼆进制⽂件/可执⾏⽂件的路径</td>
</tr>
<tr>
<td>which &lt;关键词&gt;</td>
<td>查找系统⽬录下某的⼆进制⽂件</td>
</tr>
<tr>
<td>chmod ugo+rwx dir1</td>
<td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td>
</tr>
<tr>
<td>chmod go-rwx dir1</td>
<td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td>
</tr>
<tr>
<td>chown user1 file1</td>
<td>改变⽂件的所有者属性</td>
</tr>
<tr>
<td>chown -R user1 dir1</td>
<td>改变⽬录的所有者属性</td>
</tr>
<tr>
<td>chgrp group1 file1</td>
<td>改变⽂件群组</td>
</tr>
<tr>
<td>chown user1:group1 file1</td>
<td>改变⽂件的所有⼈和群组</td>
</tr>
</tbody></table>
<h1 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>zip xxx.zip file</td>
<td>压缩⾄zip包</td>
</tr>
<tr>
<td>zip -r xxx.zip file1 file2 dir1</td>
<td>将多个⽂件+⽬录压成zip包</td>
</tr>
<tr>
<td>unzip xxx.zip</td>
<td>解压zip包</td>
</tr>
<tr>
<td>tar -cvf xxx.tar file</td>
<td>创建⾮压缩tar包</td>
</tr>
<tr>
<td>tar -cvf xxx.tar file1 file2 dir1</td>
<td>将多个⽂件+⽬录打tar包</td>
</tr>
<tr>
<td>tar -tf xxx.tar</td>
<td>查看tar包的内容</td>
</tr>
<tr>
<td>tar -xvf xxx.tar</td>
<td>解压tar包</td>
</tr>
<tr>
<td>tar -xvf xxx.tar -C /dir</td>
<td>将tar包解压⾄指定⽬录</td>
</tr>
<tr>
<td>tar -cvfj xxx.tar.bz2 dir</td>
<td>创建bz2压缩包</td>
</tr>
<tr>
<td>tar -jxvf xxx.tar.bz2</td>
<td>解压bz2压缩包</td>
</tr>
<tr>
<td>tar -cvfz xxx.tar.gz dir</td>
<td>创建gzip压缩包</td>
</tr>
<tr>
<td>tar -zxvf xxx.tar.gz</td>
<td>解压gzip压缩包</td>
</tr>
<tr>
<td>bunzip2 xxx.bz2</td>
<td>解压bz2压缩包</td>
</tr>
<tr>
<td>bzip2 filename</td>
<td>压缩⽂件</td>
</tr>
<tr>
<td>gunzip xxx.gz</td>
<td>解压gzip压缩包</td>
</tr>
<tr>
<td>gzip filename</td>
<td>压缩⽂件</td>
</tr>
<tr>
<td>gzip -9 filename</td>
<td>最⼤程度压缩</td>
</tr>
</tbody></table>
<h1 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机/重启/注销"></a>关机/重启/注销</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>shutdown -h now</td>
<td>即刻关机</td>
</tr>
<tr>
<td>shutdown -h 10</td>
<td>10分钟后关机</td>
</tr>
<tr>
<td>shutdown -h 11:00</td>
<td>11：00关机</td>
</tr>
<tr>
<td>shutdown -h +10</td>
<td>预定时间关机（10分钟后）</td>
</tr>
<tr>
<td>shutdown -c</td>
<td>取消指定时间关机</td>
</tr>
<tr>
<td>shutdown -r now</td>
<td>重启</td>
</tr>
<tr>
<td>shutdown -r 10</td>
<td>10分钟之后重启</td>
</tr>
<tr>
<td>shutdown -r 11:00</td>
<td>定时重启</td>
</tr>
<tr>
<td>reboot</td>
<td>重启</td>
</tr>
<tr>
<td>init 6</td>
<td>重启</td>
</tr>
<tr>
<td>init 0</td>
<td>⽴刻关机</td>
</tr>
<tr>
<td>telinit 0</td>
<td>关机</td>
</tr>
<tr>
<td>poweroff</td>
<td>⽴刻关机</td>
</tr>
<tr>
<td>halt</td>
<td>关机</td>
</tr>
<tr>
<td>sync</td>
<td>buff数据同步到磁盘</td>
</tr>
<tr>
<td>logout</td>
<td>退出登录Shell</td>
</tr>
</tbody></table>
<h1 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>uname -a</td>
<td>查看内核/OS/CPU信息</td>
</tr>
<tr>
<td>uname -r</td>
<td>查看内核版本</td>
</tr>
<tr>
<td>uname -m</td>
<td>查看处理器架构</td>
</tr>
<tr>
<td>arch</td>
<td>查看处理器架构</td>
</tr>
<tr>
<td>hostname</td>
<td>查看计算机名</td>
</tr>
<tr>
<td>who</td>
<td>显示当前登录系统的⽤户</td>
</tr>
<tr>
<td>who am i</td>
<td>显示登录时的⽤户名</td>
</tr>
<tr>
<td>whoami</td>
<td>显示当前⽤户名</td>
</tr>
<tr>
<td>cat /proc/version</td>
<td>查看linux版本信息</td>
</tr>
<tr>
<td>cat /proc/cpuinfo</td>
<td>查看CPU信息</td>
</tr>
<tr>
<td>cat /proc/interrupts</td>
<td>查看中断</td>
</tr>
<tr>
<td>cat /proc/loadavg</td>
<td>查看系统负载</td>
</tr>
<tr>
<td>uptime</td>
<td>查看系统运⾏时间、⽤户数、负载</td>
</tr>
<tr>
<td>env</td>
<td>查看系统的环境变量</td>
</tr>
<tr>
<td>lsusb -tv</td>
<td>查看系统USB设备信息</td>
</tr>
<tr>
<td>lspci -tv</td>
<td>查看系统PCI设备信息</td>
</tr>
<tr>
<td>lsmod</td>
<td>查看已加载的系统模块</td>
</tr>
<tr>
<td>grep MemTotal /proc/meminfo</td>
<td>查看内存总量</td>
</tr>
<tr>
<td>grep MemFree /proc/meminfo</td>
<td>查看空闲内存量</td>
</tr>
<tr>
<td>free -m</td>
<td>查看内存⽤量和交换区⽤量</td>
</tr>
<tr>
<td>date</td>
<td>显示系统⽇期时间</td>
</tr>
<tr>
<td>cal 2021</td>
<td>显示2021⽇历表</td>
</tr>
<tr>
<td>top</td>
<td>动态显示cpu/内存/进程等情况</td>
</tr>
<tr>
<td>vmstat 1 20</td>
<td>每1秒采⼀次系统状态，采20次</td>
</tr>
<tr>
<td>iostat</td>
<td>查看io读写/cpu使⽤情况</td>
</tr>
<tr>
<td>查看io读写/cpu使⽤情况</td>
<td>查询cpu使⽤情况（1秒⼀次，共10次）</td>
</tr>
<tr>
<td>sar -d 1 10</td>
<td>查询磁盘性能</td>
</tr>
</tbody></table>
<h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>fdisk -l</td>
<td>查看所有磁盘分区</td>
</tr>
<tr>
<td>swapon -s</td>
<td>查看所有交换分区</td>
</tr>
<tr>
<td>df -h</td>
<td>查看磁盘使⽤情况及挂载点</td>
</tr>
<tr>
<td>df -hl</td>
<td>同上</td>
</tr>
<tr>
<td>du -sh /dir</td>
<td>查看指定某个⽬录的⼤⼩</td>
</tr>
<tr>
<td>du -sk * | sort -rn</td>
<td>从⾼到低依次显示⽂件和⽬录⼤⼩</td>
</tr>
<tr>
<td>mount /dev/hda2 /mnt/hda2</td>
<td>挂载hda2盘</td>
</tr>
<tr>
<td>mount -t ntfs /dev/sdc1 /mnt/usbhd1</td>
<td>指定⽂件系统类型挂载（如ntfs）</td>
</tr>
<tr>
<td>mount -o loop xxx.iso /mnt/cdrom</td>
<td>挂 载 iso ⽂ 件</td>
</tr>
<tr>
<td>umount -v /dev/sda1</td>
<td>通过设备名卸载</td>
</tr>
<tr>
<td>umount -v /mnt/mymnt</td>
<td>通过挂载点卸载</td>
</tr>
<tr>
<td>fuser -km /mnt/hda1</td>
<td>强制卸载(慎⽤)</td>
</tr>
</tbody></table>
<h1 id="⽤户和⽤户组"><a href="#⽤户和⽤户组" class="headerlink" title="⽤户和⽤户组"></a>⽤户和⽤户组</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>useradd codesheep</td>
<td>创建⽤户</td>
</tr>
<tr>
<td>userdel -r codesheep</td>
<td>删除⽤户</td>
</tr>
<tr>
<td>usermod -g group_name user_name</td>
<td>修改⽤户的组</td>
</tr>
<tr>
<td>usermod -aG group_name user_name</td>
<td>将⽤户添加到组</td>
</tr>
<tr>
<td>usermod -s /bin/ksh -d /home/codepig –g dev codesheep</td>
<td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td>
</tr>
<tr>
<td>groups test</td>
<td>查看test⽤户所在的组</td>
</tr>
<tr>
<td>groupadd group_name</td>
<td>创建⽤户组</td>
</tr>
<tr>
<td>groupdel group_name</td>
<td>删除⽤户组</td>
</tr>
<tr>
<td>groupmod -n new_name old_name</td>
<td>重命名⽤户组</td>
</tr>
<tr>
<td>su - user_name</td>
<td>su - user_name</td>
</tr>
<tr>
<td>passwd</td>
<td>修改⼝令</td>
</tr>
<tr>
<td>passwd codesheep</td>
<td>修改某⽤户的⼝令</td>
</tr>
<tr>
<td>w</td>
<td>查看活动⽤户</td>
</tr>
<tr>
<td>id codesheep</td>
<td>查看指定⽤户codesheep信息</td>
</tr>
<tr>
<td>last</td>
<td>查看⽤户登录⽇志</td>
</tr>
<tr>
<td>crontab -l</td>
<td>查看当前⽤户的计划任务</td>
</tr>
<tr>
<td>cut -d: -f1 /etc/passwd</td>
<td>查看系统所有⽤户</td>
</tr>
<tr>
<td>cut -d: -f1 /etc/group</td>
<td>查看系统所有组</td>
</tr>
</tbody></table>
<h1 id="⽹络和进程管理"><a href="#⽹络和进程管理" class="headerlink" title="⽹络和进程管理"></a>⽹络和进程管理</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ifconfig</td>
<td>查看⽹络接⼝属性</td>
</tr>
<tr>
<td>ifconfig eth0</td>
<td>查看某⽹卡的配置</td>
</tr>
<tr>
<td>route -n</td>
<td>查看路由表</td>
</tr>
<tr>
<td>netstat -lntp</td>
<td>查看所有监听端⼝</td>
</tr>
<tr>
<td>netstat -antp</td>
<td>查看已经建⽴的TCP连接</td>
</tr>
<tr>
<td>netstat -lutp</td>
<td>查看TCP/UDP的状态信息</td>
</tr>
<tr>
<td>ifup eth0</td>
<td>启⽤eth0⽹络设备</td>
</tr>
<tr>
<td>ifdown eth0</td>
<td>禁⽤eth0⽹络设备</td>
</tr>
<tr>
<td>iptables -L</td>
<td>查看iptables规则</td>
</tr>
<tr>
<td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td>
<td>配置ip地址</td>
</tr>
<tr>
<td>dhclient eth0</td>
<td>以dhcp模式启⽤eth0</td>
</tr>
<tr>
<td>route add -net 0/0 gw Gateway_IP</td>
<td>配置默认⽹关</td>
</tr>
<tr>
<td>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1</td>
<td>配置静态路由到达⽹络’192.168.0.0/16’</td>
</tr>
<tr>
<td>route del 0/0 gw Gateway_IP</td>
<td>删除静态路由</td>
</tr>
<tr>
<td>hostname</td>
<td>查看主机名</td>
</tr>
<tr>
<td>host <a href="http://www.baidu.com/">www.baidu.com</a></td>
<td>解析主机名</td>
</tr>
<tr>
<td>nslookup <a href="http://www.baidu.com/">www.baidu.com</a></td>
<td>查询DNS记录，查看域名解析是否正常</td>
</tr>
<tr>
<td>ps -ef</td>
<td>查看所有进程</td>
</tr>
<tr>
<td>ps -ef | grep codesheep</td>
<td>过滤出你需要的进程</td>
</tr>
<tr>
<td>kill -s name</td>
<td>kill指定名称的进程</td>
</tr>
<tr>
<td>kill -s pid</td>
<td>kill指定pid的进程</td>
</tr>
<tr>
<td>top</td>
<td>实时显示进程状态</td>
</tr>
<tr>
<td>vmstat 1 20</td>
<td>每1秒采⼀次系统状态，采20次</td>
</tr>
<tr>
<td>iostat</td>
<td>iostat</td>
</tr>
<tr>
<td>sar -u 1 10</td>
<td>查询cpu使⽤情况（1秒⼀次，共10次）</td>
</tr>
<tr>
<td>sar -d 1 10</td>
<td>查询磁盘性能</td>
</tr>
</tbody></table>
<h1 id="常⻅系统服务命令"><a href="#常⻅系统服务命令" class="headerlink" title="常⻅系统服务命令"></a>常⻅系统服务命令</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>chkconfig –list</td>
<td>列出系统服务</td>
</tr>
<tr>
<td>service &lt;服务名&gt; status</td>
<td>查看某个服务</td>
</tr>
<tr>
<td>service &lt;服务名&gt; start</td>
<td>启动某个服务</td>
</tr>
<tr>
<td>service &lt;服务名&gt; stop</td>
<td>终⽌某个服务</td>
</tr>
<tr>
<td>service &lt;服务名&gt; restart</td>
<td>重启某个服务</td>
</tr>
<tr>
<td>systemctl status &lt;服务名&gt;</td>
<td>查看某个服务</td>
</tr>
<tr>
<td>systemctl start &lt;服务名&gt;</td>
<td>启动某个服务</td>
</tr>
<tr>
<td>systemctl stop &lt;服务名&gt;</td>
<td>终⽌某个服务</td>
</tr>
<tr>
<td>systemctl restart &lt;服务名&gt;</td>
<td>重启某个服务</td>
</tr>
<tr>
<td>systemctl enable &lt;服务名&gt;</td>
<td>关闭⾃启动</td>
</tr>
<tr>
<td>systemctl disable &lt;服务名&gt;</td>
<td>关闭⾃启动</td>
</tr>
</tbody></table>
<h1 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>rpm -qa</td>
<td>查看已安装的rpm包</td>
</tr>
<tr>
<td>rpm -q pkg_name</td>
<td>查询某个rpm包</td>
</tr>
<tr>
<td>rpm -q –whatprovides xxx</td>
<td>显示xxx功能是由哪个包提供的</td>
</tr>
<tr>
<td>rpm -q –whatrequires xxx</td>
<td>显示xxx功能被哪个程序包依赖的</td>
</tr>
<tr>
<td>rpm -q –changelog xxx</td>
<td>显示xxx包的更改记录</td>
</tr>
<tr>
<td>rpm -qi pkg_name</td>
<td>查看⼀个包的详细信息</td>
</tr>
<tr>
<td>rpm -qd pkg_name</td>
<td>查询⼀个包所提供的⽂档</td>
</tr>
<tr>
<td>rpm -qc pkg_name</td>
<td>查看已安装rpm包提供的配置⽂件</td>
</tr>
<tr>
<td>rpm -ql pkg_name</td>
<td>查看⼀个包安装了哪些⽂件</td>
</tr>
<tr>
<td>rpm -qf filename</td>
<td>查看某个⽂件属于哪个包</td>
</tr>
<tr>
<td>rpm -qR pkg_name</td>
<td>查询包的依赖关系</td>
</tr>
<tr>
<td>rpm -ivh xxx.rpm</td>
<td>安装rpm包</td>
</tr>
<tr>
<td>rpm -ivh –test xxx.rpm</td>
<td>测试安装rpm包</td>
</tr>
<tr>
<td>rpm -ivh –nodeps xxx.rpm</td>
<td>安装rpm包时忽略依赖关系</td>
</tr>
<tr>
<td>rpm -e xxx</td>
<td>卸载程序包</td>
</tr>
<tr>
<td>rpm -Fvh pkg_name</td>
<td>升级确定已安装的rpm包</td>
</tr>
<tr>
<td>rpm -Uvh pkg_name</td>
<td>升级rpm包(若未安装则会安装)</td>
</tr>
<tr>
<td>rpm -V pkg_name</td>
<td>RPM包详细信息校验</td>
</tr>
</tbody></table>
<h1 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>yum repolist enabled</td>
<td>显示可⽤的源仓库</td>
</tr>
<tr>
<td>yum search pkg_name</td>
<td>搜索软件包</td>
</tr>
<tr>
<td>yum install pkg_name</td>
<td>下载并安装软件包</td>
</tr>
<tr>
<td>yum install –downloadonly pkg_name</td>
<td>只 下 载 不 安 装</td>
</tr>
<tr>
<td>yum list</td>
<td>显示所有程序包</td>
</tr>
<tr>
<td>yum list installed</td>
<td>查看当前系统已安装包</td>
</tr>
<tr>
<td>yum list updates</td>
<td>查看可以更新的包列表</td>
</tr>
<tr>
<td>yum check-update</td>
<td>查看可升级的软件包</td>
</tr>
<tr>
<td>yum update</td>
<td>更新所有软件包</td>
</tr>
<tr>
<td>yum update pkg_name</td>
<td>升级指定软件包</td>
</tr>
<tr>
<td>yum deplist pkg_name</td>
<td>列出软件包依赖关系</td>
</tr>
<tr>
<td>yum remove pkg_name</td>
<td>删除软件包</td>
</tr>
<tr>
<td>yum clean all</td>
<td>清除缓存</td>
</tr>
<tr>
<td>yum clean packages</td>
<td>清除缓存的软件包</td>
</tr>
<tr>
<td>yum clean headers</td>
<td>清除缓存的header</td>
</tr>
</tbody></table>
<h1 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>dpkg -c xxx.deb</td>
<td>列出deb包的内容</td>
</tr>
<tr>
<td>dpkg -i xxx.deb</td>
<td>安装/更新deb包</td>
</tr>
<tr>
<td>dpkg -r pkg_name</td>
<td>移除deb包</td>
</tr>
<tr>
<td>dpkg -P pkg_name</td>
<td>移除deb包(不保留配置)</td>
</tr>
<tr>
<td>dpkg -l</td>
<td>查看系统中已安装deb包</td>
</tr>
<tr>
<td>dpkg -l pkg_name</td>
<td>显示包的⼤致信息</td>
</tr>
<tr>
<td>dpkg -L pkg_name</td>
<td>查看deb包安装的⽂件</td>
</tr>
<tr>
<td>dpkg -s pkg_name</td>
<td>查看包的详细信息</td>
</tr>
<tr>
<td>dpkg –unpack xxx.deb</td>
<td>解开deb包的内容</td>
</tr>
</tbody></table>
<h1 id="APT软件⼯具"><a href="#APT软件⼯具" class="headerlink" title="APT软件⼯具"></a>APT软件⼯具</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>apt-cache search pkg_name</td>
<td>搜索程序包</td>
</tr>
<tr>
<td>apt-cache show pkg_name</td>
<td>获取包的概览信息</td>
</tr>
<tr>
<td>apt-get install pkg_name</td>
<td>安装/升级软件包</td>
</tr>
<tr>
<td>apt-get purge pkg_name</td>
<td>卸载软件（包括配置）</td>
</tr>
<tr>
<td>apt-get remove pkg_name</td>
<td>卸载软件（不包括配置）</td>
</tr>
<tr>
<td>apt-get update</td>
<td>更新包索引信息</td>
</tr>
<tr>
<td>apt-get upgrade</td>
<td>更新已安装软件包</td>
</tr>
<tr>
<td>apt-get clean</td>
<td>清理缓存</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ant 使用分享</title>
    <url>/2021/11/11/ant-%E4%BD%BF%E7%94%A8%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="一、概述、功能"><a href="#一、概述、功能" class="headerlink" title="一、概述、功能"></a>一、概述、功能</h1><ol>
<li>Ant是Java的生成工具，是Apache的核心项目，并且是Ant是跨平台的</li>
<li>Ant的主要目的就是把你想做的事情自动化，不用你手动一步一步做，因为里面内置了javac、java、创建目录、复制文件等功能，所以可以直接点击Ant文件，即可编译生成你的项目</li>
<li>可以实现件夹、文件新增、复制、删除，压缩等一系列操作；可以编译java文件，打jar包，实现项目的编译部署工作；通过ftp，可以与服务器建立连接，传文件，执行远程服务器脚本操作</li>
</ol>
<span id="more"></span>

<h1 id="二、安装使用"><a href="#二、安装使用" class="headerlink" title="二、安装使用"></a>二、安装使用</h1><h2 id="1-Windows环境"><a href="#1-Windows环境" class="headerlink" title="1. Windows环境"></a>1. Windows环境</h2><p>1：下载ant包：<a href="http://ant.apache.org/bindownload.cgi">http://ant.apache.org/bindownload.cgi</a></p>
<p>2：提前配置java环境变量，配置好JAVA_HOME为jdk主目录；</p>
<p>3：新建环境变量ANT_HOME：值为ANT的主目录；</p>
<p>4：在path中配置%ANT_HOME%/bin；</p>
<p>5：配置完成之后，打开命令行，输入ant，当出现“Buildfile: build.xml does not exist! Build failed”时说明配置完成；</p>
<h2 id="2-Linux环境"><a href="#2-Linux环境" class="headerlink" title="2. Linux环境"></a>2. Linux环境</h2><p>1：下载ant包：<a href="http://ant.apache.org/bindownload.cgi">http://ant.apache.org/bindownload.cgi</a>  例如apache-ant-1.10.4-bin.tar.gz</p>
<p>2：复制到Linux /usr目录下 解压、改变权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf  apac-ant-1.10.4-bin.tar.gz</span><br><span class="line">chmod 777  apache-ant-1.10.4</span><br></pre></td></tr></table></figure>

<p>3：修改系统环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>

<p>4：在文件最后两行加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#set Ant enviroment</span><br><span class="line">export ANT_HOME=/usr/apache-ant-1.9.2</span><br><span class="line">export PATH=$PATH:$ANT_HOME/bin</span><br></pre></td></tr></table></figure>

<p>5：使环境变量生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>6：测试ant是否生效：</p>
<p>​     输入ant -version 即可，出现版本号，证明安装成功</p>
<h1 id="三、入门使用"><a href="#三、入门使用" class="headerlink" title="三、入门使用"></a>三、入门使用</h1><h3 id="1-执行"><a href="#1-执行" class="headerlink" title="1. 执行"></a>1. 执行</h3><p>ant的默认生成文件为build.xml</p>
<p>Win+R 运行cmd 命令行输入ant后，ant会在当前目录搜索是否有build.xml,如果有则执行；也可以自定义xml文件，执行 ant -f test.xml 执行当前目录下 test.xml文件</p>
<h3 id="2-执行文件架构"><a href="#2-执行文件架构" class="headerlink" title="2.执行文件架构"></a>2.执行文件架构</h3><p>Ant可执行文件格式是xml,整体结构为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project default=&quot;targetname&quot;&gt;  </span><br><span class="line">    &lt;target name=&quot;name&quot;&gt;  </span><br><span class="line">    &lt;/target&gt;  </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>project 是执行文件的根元素，表示一个项目</p>
<p>target是project的子元素，表示一个任务；一个project中可以定义多个target元素，表示多个任务；</p>
<p>default 属性 表示这个项目默认执行的任务是那个，对应target 的name属性</p>
<p>直接输入 ant targetname; 则会执行具体的target任务，从而忽略default设置的target，target 的name属性不能重复，是target任务的唯一属性</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!-- 删除D:\project\targeet下的classes目录，完成后输出All Done! --&gt;</span><br><span class="line">&lt;project default=&quot;deploy&quot;&gt;</span><br><span class="line">    &lt;!-- 定义路径 --&gt;</span><br><span class="line">    &lt;property name=&quot;path&quot; location=&quot;D:\project&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;dir.path&quot; location=&quot;$&#123;path&#125;/target/classes&quot; /&gt;</span><br><span class="line">	&lt;target name=&quot;clean&quot; &gt;</span><br><span class="line">		&lt;delete dir=&quot;$&#123;dir.path&#125;&quot;/&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">	&lt;target name=&quot;deploy&quot; depends=&quot;clean&quot;&gt;</span><br><span class="line">		&lt;echo message=&quot;All Done !&quot; /&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<h1 id="四、详细属性介绍"><a href="#四、详细属性介绍" class="headerlink" title="四、详细属性介绍"></a>四、详细属性介绍</h1><h2 id="一、Xml元素详解"><a href="#一、Xml元素详解" class="headerlink" title="一、Xml元素详解"></a>一、Xml元素详解</h2><h4 id="1-project元素"><a href="#1-project元素" class="headerlink" title="1. project元素"></a>1. project元素</h4><p>Ant生成文件的根元素，一般形式如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project default=&quot;    &quot;[ basedir=&quot;.&quot; ] [name=&quot;projectname&quot;]&gt;</span><br></pre></td></tr></table></figure>

<p>default的值是默认执行的target名；<br>basedir是指定基准目录，一般都是basedir=”.”；<br>name是指工程名字。</p>
<h4 id="2-target元素"><a href="#2-target元素" class="headerlink" title="2. target元素"></a>2. target元素</h4><p>是project元素的子元素，在project元素中能够有多个target；一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;target name=&quot; &quot;  [ depends=&quot;A&quot;]  [ if =&quot;prop1&quot;] [ unless=&quot;prop2&quot;]&gt;</span><br><span class="line">&lt;/target&gt;</span><br></pre></td></tr></table></figure>

<p>name表示target的名称；<br>depends中填写其他target名称(可以有多个名称，用逗号分割)，表示只有targetA完成之后才能够做此target，如果执行此target，则会先执行A；<br>if的值表示一个属性名，只有设置了该属性名，才能执行此target；<br>unless的值表示一个属性名，只有没有设置该属性名，才能执行此target。</p>
<h4 id="3-property元素"><a href="#3-property元素" class="headerlink" title="3. property元素"></a>3. property元素</h4><p>project的子元素，用于定义属性，一般形如：<br><code>&lt;property name=&quot;pname&quot; value=&quot;pvalue&quot;/&gt;</code><br>如果要使用此property，则需要${pname}，类似于表达式语言；<br>&lt;property file=”a.properties”/&gt;通过此属性文件导入属性；<br>如果单纯想使用$，则通过$$表示。</p>
<h2 id="二、Task详解"><a href="#二、Task详解" class="headerlink" title="二、Task详解"></a>二、Task详解</h2><p>在Ant中task是target的子元素，即一个target中可以有多个task；Task可以分以下三类</p>
<p>（1）核心Task</p>
<p>（2）可选Task</p>
<p>（3）自定义task</p>
<h5 id="1-echo"><a href="#1-echo" class="headerlink" title="1:echo"></a>1:echo</h5><p>用于单纯输出，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;echo&gt;hello word&lt;/echo&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-zip"><a href="#2-zip" class="headerlink" title="2: zip"></a><strong>2</strong>: zip</h5><p>压缩文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;zip destfile=&quot;目标文件.zip&quot;&gt;</span><br><span class="line">   &lt;zipfileset dir=&quot;要压缩的文件内容&quot; prefix=&quot;citsb2b&quot;&gt;   &lt;/zipfileset&gt; --将要压缩的文件存放到citsb2b下</span><br><span class="line">&lt;/zip&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-scp"><a href="#3-scp" class="headerlink" title="3: scp"></a>3: scp</h5><p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scp todir=&quot;$&#123;weblogicUser&#125;:$&#123;weblogicPwd&#125;@$&#123;weblogicSvr&#125;:$&#123;weblogicPath&#125;&quot; trust=&quot;true&quot;&gt;</span><br><span class="line"> &lt;fileset dir=&quot;$&#123;outputDir&#125;&quot;&gt;</span><br><span class="line"> &lt;!-- 上传全量包--&gt;</span><br><span class="line"> &lt;include name=&quot;**/*$&#123;DSTAMP&#125;_$&#123;TSTAMP&#125;*&quot; /&gt;</span><br><span class="line"> &lt;exclude name=&quot;**/*$&#123;DSTAMP&#125;_$&#123;TSTAMP&#125;_Patch*&quot; /&gt;</span><br><span class="line"> &lt;/fileset&gt;</span><br><span class="line">&lt;/scp&gt;</span><br></pre></td></tr></table></figure>

<h5 id="4-sshexec"><a href="#4-sshexec" class="headerlink" title="4: sshexec"></a>4: sshexec</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sshexec host=&quot;$&#123;weblogicSvr&#125;&quot; username=&quot;$&#123;weblogicUser&#125;&quot; password=&quot;$&#123;weblogicPwd&#125;&quot; command=&quot;cd $&#123;weblogicPath&#125;;cd ..; sh restart.sh $&#123;citsonline_outputName&#125; $&#123;citsb2b_outputName&#125;&quot; trust=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h5 id="5-javac"><a href="#5-javac" class="headerlink" title="5: javac"></a>5: javac</h5><p> 用来编译java文件，一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;javac srcdir=&quot;src&quot; destdir=&quot;class&quot; [classpath=&quot; &quot;]/&gt;</span><br></pre></td></tr></table></figure>

<p>srcdir是编译此文件夹下或子文件夹下的全部java文件;<br>destdir是编译后的class文件放置路径；<br>classpath指定第三方类库；</p>
<h5 id="6-java"><a href="#6-java" class="headerlink" title="6: java"></a>6: java</h5><p>运行java类，一般形式如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Java classname=&quot; &quot; fork=&quot;yes&quot;&gt;</span><br><span class="line">    【&lt;arg line=&quot;param1   param2   param3&quot;/&gt;】</span><br><span class="line">&lt;/java&gt;</span><br></pre></td></tr></table></figure>

<p>classname用于指定运行的类名称；<br>fork=”yes”表示另起一个JVM来执行java命令，而不是中断ANT命令，因此fork必须为yes；</p>
<h5 id="7-jar"><a href="#7-jar" class="headerlink" title="7: jar"></a>7: jar</h5><p>将文件目录或者文件达成jar包，一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;jar basedir=&quot;citsonlineBase/classes&quot;   destfile=&quot;citsonlineBase.jar&quot; /&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;jar destfile=&quot;main.jar&quot; basedir=&quot; &quot;&gt;</span><br><span class="line">    &lt;manifest&gt;</span><br><span class="line">        &lt;attribute name=&quot;Main-Class&quot; value=&quot;classname&quot;/&gt;  &lt;!--指定主类--&gt;</span><br><span class="line">    &lt;/manifest&gt;</span><br><span class="line">&lt;/jar&gt;</span><br></pre></td></tr></table></figure>

<p>destfiie的值为jar包的名称，一般为<code>$&#123;dest&#125;/main.jar</code>；<br>basedir的值是需要打成jar包的目录，一般为${classes}；<br>manifest表示设置META-INF； </p>
<h5 id="8-mkdir"><a href="#8-mkdir" class="headerlink" title="8: mkdir"></a>8: mkdir</h5><p>创建目录，可以多层创建，比如a\b\c，则可以连续创建，一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mkdir dir=&quot;a\b&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h5 id="9-delete"><a href="#9-delete" class="headerlink" title="9: delete"></a>9: delete</h5><p>删除目录，一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;delete dir=&quot;a\b&quot;/&gt; 可以删除a目录下的b目录；</span><br><span class="line">&lt;delete file=&quot;1.txt&quot;/&gt;可以删除文件；</span><br></pre></td></tr></table></figure>

<h5 id="10-tstamp"><a href="#10-tstamp" class="headerlink" title="10: tstamp"></a>10: tstamp</h5><p>时间戳，一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tstamp /&gt;</span><br></pre></td></tr></table></figure>

<p>接下来可以使用${DSTAMP}进行调用当前时间；</p>
<h5 id="11-copy"><a href="#11-copy" class="headerlink" title="11: copy"></a>11: copy</h5><p> 复制文件，一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;copy file=&quot;file1&quot; tofile=&quot;file2&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>file是源文件；<br>tofile是目标文件；</p>
<h5 id="12-move"><a href="#12-move" class="headerlink" title="12: move"></a>12: move</h5><p> 移动文件，一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;move file=&quot;file1&quot; tofile=&quot;file2&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>file是源文件；<br>tofile是目标文件；</p>
<h5 id="13-replace"><a href="#13-replace" class="headerlink" title="13: replace"></a>13: replace</h5><p>用于替换字符串，类似于String的replace操作，一般形式如下：</p>
<p>file表示要执行替换的文件；<br>token表示被替换的字符串；<br>value表示替换的字符串。</p>
<h1 id="五、示例代码"><a href="#五、示例代码" class="headerlink" title="五、示例代码"></a>五、示例代码</h1><h2 id="一、示例一：deploy-clean-windows-xml"><a href="#一、示例一：deploy-clean-windows-xml" class="headerlink" title="一、示例一：deploy_clean_windows.xml"></a>一、示例一：deploy_clean_windows.xml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 将服务器目录下文件删除，将重新生成的编译文件以指定格式传到服务器指定目录下 --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project name=&quot;citsonlinePJ&quot; default=&quot;deploy&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 配置信息 Start--&gt;</span><br><span class="line">	&lt;property name=&quot;projectHome&quot;  value=&quot;D:\project\citsb2b\workspace&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;outputDir&quot;    value=&quot;D:\project\citsb2b\tools\wls1036_dev\user_projects\domains\base_domain\applications&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;citsonline_appHome&quot;  value=&quot;$&#123;outputDir&#125;\citsonline&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;citsb2b_appHome&quot;  value=&quot;$&#123;outputDir&#125;\citsb2b&quot; /&gt;</span><br><span class="line">	&lt;!-- 配置信息 End --&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;target name=&quot;clean&quot;&gt;</span><br><span class="line">		&lt;echo message=&quot;clean citsonline and citsb2b directory start !&quot; /&gt;</span><br><span class="line">		&lt;delete dir=&quot;$&#123;citsonline_appHome&#125;&quot; includeemptydirs=&quot;yes&quot; /&gt;</span><br><span class="line">		&lt;delete dir=&quot;$&#123;citsb2b_appHome&#125;&quot; includeemptydirs=&quot;yes&quot; /&gt;</span><br><span class="line">		&lt;echo message=&quot;clean citsonline and citsb2b directory end !&quot; /&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">	</span><br><span class="line">    &lt;target name=&quot;citsb2b_build&quot; depends=&quot;clean&quot;&gt;</span><br><span class="line">    	&lt;echo message=&quot;build citsb2b project start !&quot; /&gt;</span><br><span class="line">        &lt;copy todir=&quot;$&#123;citsb2b_appHome&#125;&quot;&gt;</span><br><span class="line">            &lt;fileset dir=&quot;$&#123;projectHome&#125;/citsb2b/EarContent&quot; /&gt;</span><br><span class="line">        &lt;/copy&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;copy todir=&quot;$&#123;citsb2b_appHome&#125;/citsb2bWeb/WEB-INF/lib&quot;&gt;</span><br><span class="line">            &lt;fileset dir=&quot;$&#123;projectHome&#125;/citsb2b/EarContent/APP-INF/lib&quot;&gt;</span><br><span class="line">                &lt;include name=&quot;spring-*.jar&quot; /&gt;</span><br><span class="line">                &lt;include name=&quot;standard.jar&quot; /&gt;</span><br><span class="line">                &lt;include name=&quot;jstl.jar&quot; /&gt;</span><br><span class="line">            &lt;/fileset&gt;</span><br><span class="line">        &lt;/copy&gt;</span><br><span class="line"></span><br><span class="line">        &lt;copy todir=&quot;$&#123;citsb2b_appHome&#125;/citsb2bWeb/WEB-INF/classes&quot;&gt;</span><br><span class="line">            &lt;fileset dir=&quot;$&#123;projectHome&#125;/citsb2bWeb/classes&quot; /&gt;</span><br><span class="line">        &lt;/copy&gt;</span><br><span class="line"></span><br><span class="line">        &lt;copy todir=&quot;$&#123;citsb2b_appHome&#125;/citsb2bWeb&quot;&gt;</span><br><span class="line">            &lt;fileset dir=&quot;$&#123;projectHome&#125;/citsb2bWeb/WebContent&quot; /&gt;</span><br><span class="line">        &lt;/copy&gt;</span><br><span class="line">    	&lt;echo message=&quot;build citsb2b project end !&quot; /&gt;</span><br><span class="line">    &lt;/target&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;target name=&quot;citsonline_build&quot; depends=&quot;citsb2b_build&quot;&gt;</span><br><span class="line">		&lt;echo message=&quot;build citsonline project start !&quot; /&gt;</span><br><span class="line">		&lt;jar basedir=&quot;$&#123;projectHome&#125;/citsonlineBase/classes&quot;     destfile=&quot;$&#123;citsonline_appHome&#125;/lib/citsonlineBase.jar&quot; /&gt;</span><br><span class="line">		&lt;jar basedir=&quot;$&#123;projectHome&#125;/citsonlineBuzLogic/classes&quot; destfile=&quot;$&#123;citsonline_appHome&#125;/lib/citsonlineBuzLogic.jar&quot; /&gt;</span><br><span class="line">		&lt;jar basedir=&quot;$&#123;projectHome&#125;/citsonlineCommon/classes&quot;   destfile=&quot;$&#123;citsonline_appHome&#125;/lib/citsonlineCommon.jar&quot; /&gt;</span><br><span class="line">		&lt;jar basedir=&quot;$&#123;projectHome&#125;/simplemapping/classes&quot;      destfile=&quot;$&#123;citsonline_appHome&#125;/lib/simplemapping.jar&quot; /&gt;</span><br><span class="line"></span><br><span class="line">		&lt;copy todir=&quot;$&#123;citsonline_appHome&#125;&quot;&gt;</span><br><span class="line">			&lt;fileset dir=&quot;$&#123;projectHome&#125;/citsonline/EarContent&quot; /&gt;</span><br><span class="line">		&lt;/copy&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;copy todir=&quot;$&#123;citsonline_appHome&#125;/citsonlineEJB&quot;&gt;</span><br><span class="line">			&lt;fileset dir=&quot;$&#123;projectHome&#125;/citsonlineEJB/classes&quot; /&gt;</span><br><span class="line">		&lt;/copy&gt;</span><br><span class="line"></span><br><span class="line">		&lt;copy todir=&quot;$&#123;citsonline_appHome&#125;/citsonlineWeb/WEB-INF/classes&quot;&gt;</span><br><span class="line">			&lt;fileset dir=&quot;$&#123;projectHome&#125;/citsonlineWeb/classes&quot; /&gt;</span><br><span class="line">		&lt;/copy&gt;</span><br><span class="line"></span><br><span class="line">		&lt;copy todir=&quot;$&#123;citsonline_appHome&#125;/citsonlineWeb&quot;&gt;</span><br><span class="line">			&lt;fileset dir=&quot;$&#123;projectHome&#125;/citsonlineWeb/WebRoot&quot; /&gt;</span><br><span class="line">		&lt;/copy&gt;</span><br><span class="line"></span><br><span class="line">		&lt;copy todir=&quot;$&#123;citsonline_appHome&#125;/citsonlineWeb&quot;&gt;</span><br><span class="line">			&lt;fileset dir=&quot;$&#123;projectHome&#125;/citsonlineWeb/WebRoot&quot; /&gt;</span><br><span class="line">		&lt;/copy&gt;</span><br><span class="line">		&lt;echo message=&quot;build citsonline project end !&quot; /&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;target name=&quot;deploy&quot; depends=&quot;citsonline_build&quot;&gt;</span><br><span class="line">		&lt;echo message=&quot;All Done !&quot; /&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、示例二-build-zip-upload-full-xml"><a href="#二、示例二-build-zip-upload-full-xml" class="headerlink" title="二、示例二: build_zip_upload_full.xml"></a>二、示例二: build_zip_upload_full.xml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--将项目编译处的文件以压缩包方式通过ftp上传到服务器，并执行服务器脚本来重启项目--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project name=&quot;citsonlinePJ&quot; default=&quot;deploy&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;tstamp&gt;</span><br><span class="line">		&lt;format property=&quot;now&quot; pattern=&quot;yyyy-MM-dd HH:mm&quot; /&gt;</span><br><span class="line">	&lt;/tstamp&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property file=&quot;./servermsg.properties&quot; /&gt;</span><br><span class="line">	&lt;!--服务器连接 只需改前缀 例如改为90服务器只需把20改为90即可。目前支持20、24、90服务器--&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property name=&quot;weblogicSvr&quot;  value=&quot;$&#123;ip&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;weblogicUser&quot; value=&quot;$&#123;username&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;weblogicPwd&quot;  value=&quot;$&#123;pwd&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;weblogicPath&quot; value=&quot;$&#123;path&#125;&quot; /&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property name=&quot;projectHome&quot;  value=&quot;D:\project\citsb2b\workspace&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;outputDir&quot;    value=&quot;$&#123;projectHome&#125;/[output]/$&#123;weblogicSvr&#125;&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;citsonline_outputName&quot;   value=&quot;citsonline_release16_$&#123;DSTAMP&#125;_$&#123;TSTAMP&#125;.zip&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;citsonline_outputFile&quot;   value=&quot;$&#123;projectHome&#125;/[output]/$&#123;weblogicSvr&#125;/$&#123;citsonline_outputName&#125;&quot; /&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property name=&quot;citsb2b_outputName&quot;   value=&quot;citsb2b_release_$&#123;DSTAMP&#125;_$&#123;TSTAMP&#125;.zip&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;citsb2b_outputFile&quot;   value=&quot;$&#123;projectHome&#125;/[output]/$&#123;weblogicSvr&#125;/$&#123;citsb2b_outputName&#125;&quot; /&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--编译 citsb2b项目--&gt;</span><br><span class="line">	&lt;target name=&quot;citsb2b_bild&quot;&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;zip destfile=&quot;$&#123;citsb2b_outputFile&#125;&quot;&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;projectHome&#125;/citsb2b/EarContent&quot; prefix=&quot;citsb2b&quot;&gt;&lt;/zipfileset&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;projectHome&#125;/citsb2b/EarContent/APP-INF/lib&quot; prefix=&quot;citsb2b/citsb2bWeb/WEB-INF/lib&quot;&gt;</span><br><span class="line">				&lt;include name=&quot;spring-*.jar&quot; /&gt;</span><br><span class="line">				&lt;include name=&quot;standard.jar&quot; /&gt;</span><br><span class="line">				&lt;include name=&quot;jstl.jar&quot; /&gt;</span><br><span class="line">			&lt;/zipfileset&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;projectHome&#125;/citsb2bWeb/classes&quot; prefix=&quot;citsb2b/citsb2bWeb/WEB-INF/classes&quot;&gt;&lt;/zipfileset&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;projectHome&#125;/citsb2bWeb/WebContent&quot; prefix=&quot;citsb2b/citsb2bWeb&quot;&gt;&lt;/zipfileset&gt;</span><br><span class="line">		&lt;/zip&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--编译 citsonline项目--&gt;</span><br><span class="line">	&lt;target name=&quot;build&quot; depends=&quot;citsb2b_bild&quot;&gt;</span><br><span class="line">		&lt;jar basedir=&quot;$&#123;projectHome&#125;/citsonlineBase/classes&quot;     destfile=&quot;$&#123;outputDir&#125;/tmp/lib/citsonlineBase.jar&quot; /&gt;</span><br><span class="line">		&lt;jar basedir=&quot;$&#123;projectHome&#125;/citsonlineBuzLogic/classes&quot; destfile=&quot;$&#123;outputDir&#125;/tmp/lib/citsonlineBuzLogic.jar&quot; /&gt;</span><br><span class="line">		&lt;jar basedir=&quot;$&#123;projectHome&#125;/citsonlineCommon/classes&quot;   destfile=&quot;$&#123;outputDir&#125;/tmp/lib/citsonlineCommon.jar&quot; /&gt;</span><br><span class="line">		&lt;jar basedir=&quot;$&#123;projectHome&#125;/simplemapping/classes&quot;      destfile=&quot;$&#123;outputDir&#125;/tmp/lib/simplemapping.jar&quot; /&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;zip destfile=&quot;$&#123;citsonline_outputFile&#125;&quot;&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;projectHome&#125;/citsonline/EarContent&quot; prefix=&quot;citsonline&quot;&gt;&lt;/zipfileset&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;projectHome&#125;/citsonlineEJB/classes&quot; prefix=&quot;citsonline/citsonlineEJB&quot; &gt;&lt;/zipfileset&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;projectHome&#125;/citsonlineWeb/classes&quot; prefix=&quot;citsonline/citsonlineWeb/WEB-INF/classes&quot;&gt;&lt;/zipfileset&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;projectHome&#125;/citsonlineWeb/WebRoot&quot; prefix=&quot;citsonline/citsonlineWeb&quot;&gt;&lt;/zipfileset&gt;</span><br><span class="line">			&lt;zipfileset dir=&quot;$&#123;outputDir&#125;/tmp/lib&quot; prefix=&quot;citsonline/lib&quot;&gt;&lt;/zipfileset&gt;</span><br><span class="line">		&lt;/zip&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!--打增量包 --&gt;</span><br><span class="line">	&lt;target name=&quot;patch&quot; depends=&quot;build&quot;&gt;</span><br><span class="line">		&lt;!--citsb2b --&gt;</span><br><span class="line">		&lt;java fork=&quot;true&quot; classname=&quot;com.cits.online.common.BuildPatch&quot;&gt;</span><br><span class="line">			&lt;classpath path=&quot;$&#123;projectHome&#125;/citsonlineBase/classes&quot;&gt;&lt;/classpath&gt;</span><br><span class="line">			&lt;classpath path=&quot;$&#123;projectHome&#125;/citsonline/build/lib/ant.jar&quot;&gt;&lt;/classpath&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;arg value=&quot;$&#123;outputDir&#125;&quot; /&gt;</span><br><span class="line">			&lt;arg value=&quot;$&#123;citsb2b_outputName&#125;&quot; /&gt;</span><br><span class="line">		&lt;/java&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;!--citsonline --&gt;</span><br><span class="line">		&lt;java fork=&quot;true&quot; classname=&quot;com.cits.online.common.BuildPatch&quot;&gt;</span><br><span class="line">			&lt;classpath path=&quot;$&#123;projectHome&#125;/citsonlineBase/classes&quot;&gt;&lt;/classpath&gt;</span><br><span class="line">			&lt;classpath path=&quot;$&#123;projectHome&#125;/citsonline/build/lib/ant.jar&quot;&gt;&lt;/classpath&gt;</span><br><span class="line"></span><br><span class="line">			&lt;arg value=&quot;$&#123;outputDir&#125;&quot; /&gt;</span><br><span class="line">			&lt;arg value=&quot;$&#123;citsonline_outputName&#125;&quot; /&gt;</span><br><span class="line">		&lt;/java&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--同步到服务器 --&gt;</span><br><span class="line">	&lt;target name=&quot;ftp&quot; depends=&quot;patch&quot;&gt;</span><br><span class="line">		&lt;echo message=&quot;FTP Transferring weblogicSvr, Upload to Weblogic start...&quot; /&gt;</span><br><span class="line">		&lt;scp todir=&quot;$&#123;weblogicUser&#125;:$&#123;weblogicPwd&#125;@$&#123;weblogicSvr&#125;:$&#123;weblogicPath&#125;&quot; trust=&quot;true&quot;&gt;</span><br><span class="line">			&lt;fileset dir=&quot;$&#123;outputDir&#125;&quot;&gt;</span><br><span class="line">				&lt;!-- 上传全量包--&gt;</span><br><span class="line">				&lt;include name=&quot;**/*$&#123;DSTAMP&#125;_$&#123;TSTAMP&#125;*&quot; /&gt;</span><br><span class="line">				&lt;exclude name=&quot;**/*$&#123;DSTAMP&#125;_$&#123;TSTAMP&#125;_Patch*&quot; /&gt;</span><br><span class="line">			&lt;/fileset&gt;</span><br><span class="line">		&lt;/scp&gt;</span><br><span class="line">		&lt;echo message=&quot;FTP Transfer weblogicSvr Done!&quot; /&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&lt;target name=&quot;clean&quot; depends=&quot;ftp&quot;&gt;</span><br><span class="line">		&lt;delete dir=&quot;$&#123;outputDir&#125;&quot; verbose=&quot;true&quot; includeemptydirs=&quot;true&quot; &gt;</span><br><span class="line">			&lt;exclude name=&quot;**/*[Base]*&quot; /&gt;</span><br><span class="line">			&lt;exclude name=&quot;**/*$&#123;DSTAMP&#125;_$&#123;TSTAMP&#125;*&quot; /&gt;</span><br><span class="line">		&lt;/delete&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;target name=&quot;run&quot; depends=&quot;ftp&quot;&gt;</span><br><span class="line">		&lt;echo message=&quot;start run restart script... !&quot; /&gt;</span><br><span class="line">		&lt;echo message=&quot; restart.sh $&#123;citsonline_outputName&#125; $&#123;citsb2b_outputName&#125;&quot; /&gt;</span><br><span class="line">		&lt;sshexec host=&quot;$&#123;weblogicSvr&#125;&quot; username=&quot;$&#123;weblogicUser&#125;&quot; password=&quot;$&#123;weblogicPwd&#125;&quot; command=&quot;cd $&#123;weblogicPath&#125;;cd ..; sh restart.sh $&#123;citsonline_outputName&#125; $&#123;citsb2b_outputName&#125;&quot; trust=&quot;true&quot;/&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;target name=&quot;deploy&quot; depends=&quot;run&quot;&gt;</span><br><span class="line">		&lt;echo message=&quot;All Done !&quot; /&gt;</span><br><span class="line">	&lt;/target&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭配typora在文档中插入图片上传到github</title>
    <url>/2021/11/10/hexo%E6%90%AD%E9%85%8Dtypora%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/</url>
    <content><![CDATA[<p>由于hexo本地图片路径和上传到github服务器上的路径不同，使用typora设置相对路径也会有问题，为了解决文章在本地插入图片和在服务器预览效果一致，跟随一下步骤即可完美解决</p>
<h2 id="一、hexo配置文件修改"><a href="#一、hexo配置文件修改" class="headerlink" title="一、hexo配置文件修改"></a>一、hexo配置文件修改</h2><ol>
<li>在博客根目录下的_config.yml文件中，找到<strong>post_asset_folder</strong>字段，属性值设为<strong>true</strong></li>
</ol>
<span id="more"></span>

<p><img src="/2021/11/10/hexo%E6%90%AD%E9%85%8Dtypora%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/image-20211111000301442.png" alt="image-20211111000301442"></p>
<ol start="2">
<li><p>当设置完<strong>post_asset_folder</strong>字段值后，使用hexo new “博客名称” 时，会生成一个博客名称文件夹和博客名称.md文件</p>
<p><img src="/2021/11/10/hexo%E6%90%AD%E9%85%8Dtypora%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/image-20211111000824606.png" alt="image-20211111000824606"></p>
<ol start="3">
<li>在文章使用中的资源可以放到对应的文件夹里，可以方便区分，这样也有一个问题，插入一张图片放一张，然后在编辑器上去引相对路径，不是很麻烦吗，答案是结合typora设置一下即可完美解决</li>
</ol>
<h2 id="二、设置Typora"><a href="#二、设置Typora" class="headerlink" title="二、设置Typora"></a>二、设置Typora</h2><ol>
<li>typora 点击格式&gt;&gt;图像&gt;&gt;全局图像设置</li>
</ol>
<img src="/2021/11/10/hexo%E6%90%AD%E9%85%8Dtypora%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/image-20211111001152225.png" alt="image-20211111001152225" style="zoom:80%;">

<ol start="2">
<li>在偏好设置处修改复制到指定路径</li>
</ol>
</li>
</ol>
<p><img src="/2021/11/10/hexo%E6%90%AD%E9%85%8Dtypora%E5%9C%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github/image-20211111001342435.png" alt="image-20211111001342435"></p>
<ol start="3">
<li>操作完成后，粘贴在文档的图片都会自动复制到跟文件同名的文件夹中去，也不用单独去存放图片和写相对路径了，是不是很nice</li>
</ol>
<h2 id="三、装插件"><a href="#三、装插件" class="headerlink" title="三、装插件"></a>三、装插件</h2><p>操作到当前步骤还未结束，</p>
<p>需要到博客的根目录下执行 npm install <a href="https://link.jianshu.com/?t=https://github.com/CodeFalling/hexo-asset-image">https://github.com/CodeFalling/hexo-asset-image</a> –save 命令来进行插件的安装。</p>
<p>以便在服务器上访问图片和本地预览访问的图片都能够正常显示</p>
<p>至此，图片问题解决，可以图文写作不是很棒嘛~</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress傻瓜式构建个人动态博客</title>
    <url>/2021/11/10/WordPress%E5%82%BB%E7%93%9C%E5%BC%8F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>之前分享了一篇hexo搭建个人博客，详细内容可以访问：<a href="https://liuzhengkaifa.github.io/2021/11/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/#more">本地搭建hexo博客并上传github</a> 那么WordPress博客与hexo有什么区别呢,到底该使用哪个</p>
</blockquote>
<h2 id="一、WordPress与hexo的区别"><a href="#一、WordPress与hexo的区别" class="headerlink" title="一、WordPress与hexo的区别"></a>一、WordPress与hexo的区别</h2><ol>
<li>搭建wordpress需要一台服务器，个人的话可以买一台云服务器，经济允许可以考虑。</li>
<li>wordpress功能更加强大，定位为一款动态博客。拥有功能完整的后台管理系统，可以审核评论，切换各种主题插件等</li>
<li>hexo定位为静态网站博客，纯静态页面资源，无需个人服务器，上传到github或者码云均可访问</li>
<li>hexo采用markdown语法，更加简练符合程序员文档书写习惯</li>
<li>hexo无需维护额外服务器，界面干净简练，经过对比之后本人还是采用了hexo作为自己的个人博客</li>
</ol>
<span id="more"></span>

<h2 id="二、安装WordPress"><a href="#二、安装WordPress" class="headerlink" title="二、安装WordPress"></a>二、安装WordPress</h2><p>安装wordpress之前就不得不介绍介绍一款超强的运维服务器管理面板<a href="https://www.bt.cn/"><strong>宝塔</strong></a> ,通过宝塔可以减省对服务器的很多复杂操作：例如安装各种软件</p>
<blockquote>
<p>git、nginx、ftp、mysql、php(wordpress是基于php开发的)</p>
</blockquote>
<h3 id="1-安装宝塔"><a href="#1-安装宝塔" class="headerlink" title="1. 安装宝塔"></a>1. 安装宝塔</h3><p>通过添加宝塔官网的立即安装按钮跳转到安装指导页面</p>
<img src="/2021/11/10/WordPress%E5%82%BB%E7%93%9C%E5%BC%8F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2/image-20211110225513203.png" alt="image-20211110225513203" style="zoom:50%;">



<p>在打开的页面直接复制代码命令，在linux服务器终端执行即可自动安装成功</p>
<img src="/2021/11/10/WordPress%E5%82%BB%E7%93%9C%E5%BC%8F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2/image-20211110225655430.png" alt="image-20211110225655430" style="zoom: 50%;">

<p>安装成功后，终端会返回宝塔的访问地址以及账号、密码，你需要把这些信息拷贝记下，通过浏览器访问即可</p>
<p><img src="/2021/11/10/WordPress%E5%82%BB%E7%93%9C%E5%BC%8F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2/image-20211110230702927.png" alt="image-20211110230702927"></p>
<p>如果访问失败，尝试将云服务器的端口安全组8888放开即可</p>
<p><img src="/2021/11/10/WordPress%E5%82%BB%E7%93%9C%E5%BC%8F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2/image-20211110230046758.png" alt="image-20211110230046758"></p>
<p>进入宝塔后根据提示下载行点击就会依次下载安装git、nginx、ftp、mysql、php、php-admin等软件，当然，你也可以从宝塔的软件商店自行下载</p>
<h3 id="2-一键部署WordPress"><a href="#2-一键部署WordPress" class="headerlink" title="2.一键部署WordPress"></a>2.一键部署WordPress</h3><ol>
<li><p>安装完宝塔后，以及相关的软件后，进入宝塔软件商店</p>
</li>
<li><p>选择一键部署，就会看到WordPress，点击一键部署即可</p>
</li>
</ol>
<p><img src="/2021/11/10/WordPress%E5%82%BB%E7%93%9C%E5%BC%8F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2/image-20211110230439730.png" alt="image-20211110230439730"></p>
<ol start="3">
<li><p>如果尚未拥有域名，域名处输入IP即可，点击提交</p>
<img src="/2021/11/10/WordPress%E5%82%BB%E7%93%9C%E5%BC%8F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2/image-20211110230906197.png" alt="image-20211110230906197" style="zoom:50%;"></li>
</ol>
<ol start="4">
<li><p>提交完成后记录相关信息，在宝塔网站一栏即生成相应站点，此时在浏览器输入自己服务器ip地址即可登录WordPress,首次使用需要注册一个账号</p>
</li>
<li><p>下面是WordPress的控制台，可以看出，功能还是相当强大，完全满足个人博客的基本需求，有想法的小伙伴赶紧行动起来</p>
<p><img src="/2021/11/10/WordPress%E5%82%BB%E7%93%9C%E5%BC%8F%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2/image-20211110231351517.png" alt="image-20211110231351517"></p>
</li>
</ol>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ol>
<li>安装WordPress的过程是不是相当简单，不用敲一行代码即可完成，但是想要长期维护博客的同学要一直管理维护一台云服务器也是要仔细考虑是否有必要</li>
<li>相对博客来说，个人觉得也许并不需要过多复杂的功能，hexo简洁的界面能够记录平时所想，定期维护到github上不是很香嘛，当然缺点也很明显，github是不是访问就断掉也是很让人心烦</li>
</ol>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>本地搭建hexo博客并上传github</title>
    <url>/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/</url>
    <content><![CDATA[<p>一、下载安装Nodejs</p>
<p><a href="https://nodejs.org/en/">官网下载地址</a></p>
<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-1024x331.png" alt="此图片的alt属性为空；文件名为image-1024x331.png"></p>
<span id="more"></span>

<p>安装 下一步下一步正常安装即可</p>

<img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-1.png" alt="此图片的alt属性为空；文件名为image-1.png" style="zoom:50%;">

<p> 二、配置环境变量</p>
<ol><li>找到nodejs安装路径，我本地安装路径：D:\installsoftware\nodejs</li><li>将安装路径配置到path： 计算机-属性-高级系统设置-环境变量-系统变量-path </li><li>校验，win+r 输入cmd，在命令窗户输入 node -v查看nodejs版本，正常输出则安装成功</li></ol>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-2.png" alt="此图片的alt属性为空；文件名为image-2.png"></p>
<p>三、安装hexo是借助npm安装，由于国内安装镜像源速度很慢，可以借助淘宝cnpm安装</p>

<p>1、命令行输入：npm install -g cnpm --registry=https://registry.npm.taobao.org</p>

<img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-4-1024x467.png" alt="此图片的alt属性为空；文件名为image-4-1024x467.png" style="zoom:67%;">

<p>2、 命令行输入：cnpm install -g hexo-cli 安装hexo</p>

<img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-5-1024x467.png" alt="此图片的alt属性为空；文件名为image-5-1024x467.png" style="zoom:67%;">

<p> 3、 新建blog目录，存放博客</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-6.png" alt="此图片的alt属性为空；文件名为image-6.png"></p>
<p>4、 命令行输入 hexo init 初始化hexo</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-7.png" alt="此图片的alt属性为空；文件名为image-7.png"></p>
<p>5、 此时hexo安装已经完成，我们通过输入 ls -l会发现hexo初始化会生成以下文件</p>

<img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-8.png" alt="此图片的alt属性为空；文件名为image-8.png" style="zoom:67%;">

<p>6、安装完成，输入命令：hexo s  来启动hexo , 启动完成，浏览器输入http://localhost:4000/ 即可访问hexo博客</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-9.png" alt="此图片的alt属性为空；文件名为image-9.png"></p>
<img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-10-1024x597.png" alt="此图片的alt属性为空；文件名为image-10-1024x597.png" style="zoom:50%;">

<p> 四、使用hexo编写博客</p>

<p>1、写一篇新文章</p>

<p>命令行输入： hexo n "我的第一篇博客文章" </p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-11.png" alt="此图片的alt属性为空；文件名为image-11.png"></p>
<p>使用编辑器或者其他工具修改博客文章</p>
<p>然后命令行输入：hexo clean 先清理一下</p>
<p>然后命令行输入：hexo g 重新生成一下博客</p>
<p>最后命令行输入：hexo s 启动一下，启动完成浏览器输入localhost:4000即可访问博客</p>

<img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-12-1024x705.png" alt="此图片的alt属性为空；文件名为image-12-1024x705.png" style="zoom:67%;">

<img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-13-1024x660.png" alt="此图片的alt属性为空；文件名为image-13-1024x660.png" style="zoom:67%;">

<p>至此hexo博客的搭建和编写已经完成</p>

<p> 五、将hexo博客部署到远端（github）,通过github即可访问博客 </p>

<p>1、github 新建一个仓库</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-14.png" alt="此图片的alt属性为空；文件名为image-14.png"></p>
<p>2、注意仓库命名，然后点击create创建仓库即可</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-15-1024x479.png" alt="此图片的alt属性为空；文件名为image-15-1024x479.png"></p>
<p> 3、需要在我们间的blog博客文件夹下装一个git部署插件</p>

<p>通过命令行输入：cnpm install --save hexo-deployer-git</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-16-1024x99.png" alt="此图片的alt属性为空；文件名为image-16-1024x99.png"></p>
<p>4、需要设置blog目录下的_config.yml，注意yml格式使用空格缩进</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-17-1024x164.png" alt="此图片的alt属性为空；文件名为image-17-1024x164.png"></p>
<p>5、保存后，命令行输入：hexo -d 即可部署远程博客，github登录方式调整可能有问题，解决方案看文章下方</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-19-1024x419.png" alt="此图片的alt属性为空；文件名为image-19-1024x419.png"></p>
<p>6、部署完成，通过访问 https://liuzhengkaifa.github.io/ 查看博客内容。 </p>

<p>六、问题</p>
<p>  在命令行 hexo d 部署博客时出现错误</p>
<p>remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</p>
<p>原因时：GitHub不再支持密码验证解决方案：SSH免密与Token登录配置，基于方便我采用了ssh免密方式登录，可参考以下步骤</p>
**cmd命令窗口需要切换到git安装目录的Git\usr\bin目录下，否则会找不到ssh-keygen命令**

<p>1、本地生成公钥</p>
<pre class="wp-block-preformatted">ssh-keygen -t rsa -C “835570372@qq.com” </pre>
<p>接着会提示这个公钥私钥的保存路径-建议直接回车就好（默认目录里)</p>
<p>接着提示输入私钥密码passphrase - 如果不想使用私钥登录的话，私钥密码为空，直接回车</p>

<p> 2、将公钥配置到github中，用编辑器打开 C:\Users\电脑名\.ssh 目录下的 id_rsa.pub</p>

<p>将内容粘贴到githun配置处</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-20-1024x440.png" alt="此图片的alt属性为空；文件名为image-20-1024x440.png"></p>
<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-21-1024x448.png" alt="此图片的alt属性为空；文件名为image-21-1024x448.png"></p>
<p>3、将_config.yml文件的repo地址改为 ssh方式地址，即可完成正常操作</p>

<p><img src="/2021/11/09/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%8A%E4%BC%A0github/image-22.png" alt="此图片的alt属性为空；文件名为image-22.png"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
